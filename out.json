{
  "../include/combinator/combinator.hpp": {
    "body": [
      "template<typename T>",
      "class fixed_point : T {",
      "  public:",
      "    explicit constexpr fixed_point (T&& t) noexcept",
      "      : T(std::forward<T>(t)) {}",
      "    template<typename... Args>",
      "    constexpr decltype(auto) operator()(Args&&... args) const",
      "      {return T::operator()(*this, std::forward<Args>(args)...);}",
      "};",
      "template<typename T>",
      "static inline constexpr decltype(auto) fix (T&& t) noexcept {",
      "  return fixed_point<T>{std::forward<T>(t)};",
      "}"
    ],
    "prefix": "combinator"
  },
  "../include/disjoint_sets/quick_find.hpp": {
    "body": [
      "class quick_find",
      "{",
      "public:",
      "  using size_type          = int;",
      "  using node_type          = int;",
      "  using group_type         = int;",
      "  using group_array_type   = std::vector<node_type>;",
      "  using members_array_type = std::vector<std::vector<node_type>>;",
      "",
      "private:",
      "  size_type          n;",
      "  group_array_type   leader;",
      "  members_array_type members;",
      "",
      "public:",
      "  quick_find (size_type n) : n(n), leader(n), members(n)",
      "  {",
      "    for (int i = 0; i < n; i++) {",
      "      leader.at(i) = i;",
      "    }",
      "    for (int i = 0; i < n; i++) {",
      "      members.at(i) = {i};",
      "    }",
      "  }",
      "",
      "  bool       is_root (int x)        const {return find(x) == x;}",
      "",
      "  size_type  size    (int x)        const {return members.at(x).size();}",
      "",
      "  bool       is_equiv(int x, int y) const {return find(x) == find(y);}",
      "",
      "  group_type find    (int x)        const {return leader.at(x);}",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  bool unite   (int x, int y) {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    for (auto child : members.at(x))",
      "    {",
      "      leader.at(child) = y;",
      "      members.at(y).push_back(child);",
      "    }",
      "    std::decay_t<decltype(members.at(x))>{}.swap(members.at(x));",
      "    return true;",
      "  }",
      "};"
    ],
    "prefix": "quick_find"
  },
  "../include/disjoint_sets/union_find_tree.hpp": {
    "body": [
      "class union_find_tree",
      "{",
      "  int n;",
      "  std::vector<int> prt;",
      "",
      "public:",
      "  union_find_tree (int n) : n(n), prt(n, -1){}",
      "",
      "  bool is_root (int x)        const {return prt.at(x) < 0;}",
      "",
      "  int  size    (int x)        const {return -prt.at(find(x));}",
      "",
      "  bool is_equiv(int x, int y) const {return find(x) == find(y);}",
      "",
      "  int  find    (int x)        const {",
      "    while (!is_root(x)) x = prt.at(x);",
      "    return x;",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // The smaller one x becomes a child of the larger one y.",
      "  bool unite   (int x, int y) {",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y)) std::swap(x, y);",
      "    prt.at(y) += prt.at(x);",
      "    prt.at(x) = y;",
      "    return true;",
      "  }",
      "};"
    ],
    "prefix": "union_find_tree"
  },
  "../include/disjoint_sets/weighted_union_find_tree.hpp": {
    "body": [
      "template <typename T>",
      "class weighted_union_find_tree",
      "{",
      "  int n;",
      "  std::vector<int> prt;",
      "  std::vector<T>   wt;",
      "",
      "public:",
      "  weighted_union_find_tree(int n) : n(n), prt(n, -1), wt(n, 0){}",
      "",
      "  bool is_root (int x)        const {return prt.at(x) < 0;}",
      "",
      "  int  size    (int x)        {return -prt.at(find(x));}",
      "",
      "  bool is_equiv(int x, int y) {return find(x) == find(y);}",
      "",
      "  T    weight  (int x)        {return wt.at(find(x));}",
      "",
      "  T    diff    (int x, int y) {return weight(x) == weight(y);}",
      "",
      "  // Path compression.",
      "  // Cannot be inline.",
      "  int  find    (int x)",
      "  {",
      "    if (is_root(x)) return x;",
      "    else",
      "    {",
      "      auto root = find(prt.at(x));",
      "      wt.at(x) += wt.at(prt.at(x));",
      "      return prt.at(x) = root;",
      "    }",
      "  }",
      "",
      "  // Returns `true` if x and y are newly connected.",
      "  // The smaller one x becomes a child of the larger one y.",
      "  bool unite   (int x, int y, T d)",
      "  {",
      "    d -= wt.at(x);",
      "    d += wt.at(y);",
      "    if ((x = find(x)) == (y = find(y))) return false;",
      "    if (size(x) > size(y))",
      "    {",
      "      std::swap(x, y);",
      "      d = -d;",
      "    }",
      "    prt.at(y) += prt.at(x);",
      "    prt.at(x) = y;",
      "    return true;",
      "  }",
      "};"
    ],
    "prefix": "weighted_union_find_tree"
  },
  "../include/graph/bellman_ford.hpp": {
    "body": [
      "template <typename T>",
      "class bellman_ford {",
      "  using edge_t = tuple<T, int, int>;",
      "  const int n, r;",
      "  const std::vector<edge_t>& edg;",
      "  bool flg;",
      "  std::vector<long long> dst;",
      "  void cal () {",
      "      dst[r] = 0;",
      "      for (int q = n; q--;) {",
      "        flg = false;",
      "        for (auto const& e : edg) {",
      "          T d; int s, t; std::tie(d, s, t) = e;",
      "          if (dst[s] == inf) continue;",
      "          if (cmn(dst[t], dst[s] + d)) flg = true;",
      "        }",
      "      }",
      "  }",
      "  public:",
      "    const T inf;",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(n), r(r), edg(edg), ",
      "      flg(false), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    bellman_ford (",
      "        const int n, const int r,",
      "        const std::vector<edge_t>& edg",
      "      ) :",
      "      bellman_ford(n, r, edg, numeric_limits<T>::max())",
      "      {",
      "      }",
      "    bool has_negative_cycle () const {return flg;}",
      "    auto& result () {return dst;}",
      "};"
    ],
    "prefix": "bellman_ford"
  },
  "../include/graph/centroid.hpp": {
    "body": [
      "class centroid_tree {",
      "  const int n;",
      "  const std::vector<std::vector<int>> grh;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<int>> ctr;",
      "  queue<tuple<int, int, int>> que;",
      "  int rt = -1;",
      "  void build ()",
      "    {",
      "      std::vector<int> sz(n);",
      "      que.emplace(-1, 0, n);",
      "      while (!que.empty()) {",
      "        int prv_ctr, start, bkt; std::tie(prv_ctr, start, bkt) = que.front(); que.pop();",
      "        int new_ctr = -1;",
      "        make_fixed_point ([&](auto dfs, int crr, int prt) -> void {",
      "            sz[crr] = 1;",
      "            for (auto const& nxt : grh[crr]) if (nxt != prt && !ckd[nxt]) {",
      "              dfs(nxt, crr); if (new_ctr != -1) return;",
      "              sz[crr] += sz[nxt];",
      "            }",
      "            if (sz[crr] * 2 >= bkt) {",
      "              for (auto const& nxt : grh[crr]) if (!ckd[nxt]) {",
      "                if (nxt != prt) que.emplace(crr, nxt, sz[nxt]);",
      "                else que.emplace(crr, nxt, bkt - sz[crr]);",
      "              }",
      "              ckd[crr] = true;",
      "              new_ctr = crr;",
      "            }",
      "          })(start, start);",
      "        if (prv_ctr == -1) rt = new_ctr;",
      "        else ctr[prv_ctr].push_back(new_ctr);",
      "      }",
      "    }",
      "  public:",
      "    centroid_tree (",
      "        std::vector<std::vector<int>> grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh), ckd(n, false),",
      "      ctr(n)",
      "      {",
      "        build();",
      "      }",
      "    auto const centroid () const {return rt;}",
      "    auto const& result () const {return ctr;}",
      "    auto const& operator [] (int i) const {return ctr[i];}",
      "    auto const size () const {return n;}",
      "};"
    ],
    "prefix": "centroid"
  },
  "../include/graph/diameter.hpp": {
    "body": [
      "template<typename T>",
      "class diameter {",
      "    struct edge {",
      "      size_t to; T cost;",
      "      edge(size_t to, T cost) : to(to), cost(cost){}",
      "    };",
      "    size_t n;",
      "    std::vector<std::vector<edge>> graph;",
      "",
      "  public:",
      "    diameter(size_t n) : n(n), graph(n){}",
      "",
      "    // Insert an edge.",
      "    void insert(size_t i, size_t j, T cost = 1) {",
      "      assert(0 <= i && i < n);",
      "      assert(0 <= j && j < n);",
      "      graph.at(i).emplace_back(j, cost);",
      "      graph.at(j).emplace_back(i, cost);",
      "    };",
      "",
      "    // Calculate the diameter.",
      "    auto operator()(size_t root = 0){",
      "      std::vector<T> depth; ",
      "      auto cal = [&] (size_t r) {",
      "        depth.assign(n, 0);",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(r, r);",
      "      };",
      "      cal(root);",
      "      auto ex = std::max_element(depth.begin(), depth.end()) - depth.begin();",
      "      cal(ex);",
      "      return *std::max_element(depth.begin(), depth.end());",
      "    }",
      "};"
    ],
    "prefix": "diameter"
  },
  "../include/graph/dijkstra.hpp": {
    "body": [
      "template <typename T>",
      "class dijkstra {",
      "  const int n, r;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dst;",
      "  void cal () {",
      "    priority_queue<",
      "      std::pair<T, int>, std::vector<std::pair<T, int>>, greater<std::pair<T, int>>",
      "      > que;",
      "    que.emplace(0, r);",
      "    while (!que.empty()) {",
      "      T crd; int crr; std::tie(crd, crr) = que.top(), que.pop();",
      "      if (!cmn(dst[crr], crd)) continue;",
      "      for (auto e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        T nxd = crd + w;",
      "        if (nxd < dst[nxt]) que.emplace(nxd, nxt);",
      "      }",
      "    }",
      "  }",
      "  public:",
      "    const T inf;",
      "    dijkstra (",
      "        const int r,",
      "        const std::vector<std::vector<std::pair<T, int>>>& grh,",
      "        const T inf = numeric_limits<T>::max()",
      "      ) :",
      "      n(grh.size()), r(r),",
      "      grh(grh), dst(n, inf), inf(inf)",
      "      {",
      "        cal();",
      "      }",
      "    auto result () const {return dst;}",
      "};"
    ],
    "prefix": "dijkstra"
  },
  "../include/graph/floyd_warshall.hpp": {
    "body": [
      "template<typename T>",
      "struct floyd_warshall {",
      "  const int n;",
      "  const T inf;",
      "  std::vector<std::vector<T>> dst;",
      "  void cal () {",
      "    for (int k = 0; k < n; k++) {",
      "      for (int i = 0; i < n; i++) {",
      "        for (int j = 0; j < n; j++) {",
      "          if (dst[i][k] != inf && dst[k][j] != inf) {",
      "            cmn(dst[i][j], dst[i][k] + dst[k][j]);",
      "          }",
      "        }",
      "      }",
      "    }",
      "  }",
      "  floyd_warshall (",
      "      const std::vector<std::vector<T>> adj,",
      "      const T inf",
      "    ) :",
      "    n(adj.size()), inf(inf), dst(adj)",
      "    {",
      "      cal();",
      "    }",
      "  auto& result () {return dst;}",
      "  bool has_negative_cycle () {",
      "    for (int i = 0; i < n; i++) if (dst[i][i] < 0) return true;",
      "    return false;",
      "  }",
      "};"
    ],
    "prefix": "floyd_warshall"
  },
  "../include/graph/heights.hpp": {
    "body": [
      "template<typename T>",
      "class calculate_heights {",
      "  const int n;",
      "  const std::vector<std::vector<std::pair<T, int>>>& grh;",
      "  std::vector<T> dp, ep;",
      "",
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }",
      "",
      "  void efs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      std::vector<T> cld = {ep[crr]};",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        cld.push_back(dp[nxt] + w);",
      "      }",
      "      sort(cld.begin(), cld.end(), greater<T>());",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        ep[nxt] = dp[nxt] + w == cld[0] ?",
      "            cld[1] + w : cld[0] + w;",
      "      }",
      "      for (auto const& e : grh[crr]) {",
      "        T w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        efs(nxt, crr);",
      "      }",
      "      chmax(dp[crr], ep[crr]);",
      "    }",
      "",
      "  public:",
      "    calculate_heights(",
      "        std::vector<std::vector<std::pair<T, int>>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      dp(n, 0),",
      "      ep(n, 0)",
      "      {",
      "        dfs();",
      "        efs();",
      "      }",
      "    ",
      "    auto operator[] (int i) const -> const T {return dp[i];}",
      "};"
    ],
    "prefix": "heights"
  },
  "../include/graph/kruskal.hpp": {
    "body": [
      "template<typename T>",
      "struct kruskal {",
      "  using edge_type = tuple<T, int, int>;",
      "  const int n;",
      "  std::vector<edge_type> edg;",
      "  std::vector<edge_type> mst;",
      "  T weight_of_mst;",
      "  kruskal (",
      "      int n,",
      "      std::vector<edge_type> edg",
      "    ) :",
      "    n(n),",
      "    edg(edg),",
      "    mst(n - 1),",
      "    weight_of_mst(0)",
      "    {",
      "      sort(edg.begin(), edg.end());",
      "      disjoint_set djs(n);",
      "      int cnt = 0;",
      "      for (auto e : edg) {",
      "        T w; int s, t; std::tie(w, s, t) = e;",
      "        if (djs.unite(s, t)) {",
      "          weight_of_mst += w;",
      "          mst[cnt] = {w, s, t};",
      "          if (++cnt == n - 1) break;",
      "        }",
      "      }",
      "      if (cnt < n - 1) assert(false);",
      "    }    ",
      "};"
    ],
    "prefix": "kruskal"
  },
  "../include/graph/low_link_tree.hpp": {
    "body": [
      "struct low_link_tree {",
      "  const int n;",
      "  const int r = 0;",
      "  int tmr = 0;",
      "  std::vector<int> ord;",
      "  std::vector<int> low;",
      "  set<int> art;",
      "  set<std::pair<int, int>> bdg;",
      "  std::vector<std::vector<int>> grh;",
      "public:",
      "  low_link_tree (",
      "    std::vector<std::vector<int>> const& grh,",
      "    const int root",
      "  )",
      "  : n(grh.size())",
      "  , r(root)",
      "  , ord(n, -1)",
      "  , low(n, -1)",
      "  , grh(grh)",
      "  {",
      "    dfs(r, r);",
      "  }",
      "  void dfs (",
      "    int crr",
      "  ,  int prt",
      "  ) {",
      "    int cnt = 0;",
      "    ord[crr] = low[crr] = tmr++;",
      "    for (int nxt : grh[crr]) {",
      "      if (ord[nxt] == -1) {",
      "        cnt++;",
      "        dfs(nxt, crr);",
      "        chmin(low[crr], low[nxt]);",
      "        if (crr != r && ord[crr] <= low[nxt]) art.insert(crr);",
      "        if (ord[crr] < low[nxt]) bdg.emplace(min(crr, nxt), max(crr, nxt));",
      "      }",
      "      if (nxt != prt) chmin(low[crr], ord[nxt]);",
      "    }",
      "    if (crr == r && cnt > 1) art.insert(crr);",
      "  }",
      "};"
    ],
    "prefix": "low_link_tree"
  },
  "../include/graph/prim.hpp": {
    "body": [
      "template <typename T>",
      "struct prim {",
      "  const int n;",
      "  std::vector<std::vector<std::pair<T, int>>> grh;",
      "  T weight_of_mst;",
      "  prim (",
      "      std::vector<std::vector<std::pair<T, int>>> grh",
      "    ) :",
      "    n(grh.size()),",
      "    grh(grh),",
      "    weight_of_mst(0)",
      "    {",
      "      std::vector<bool> ckd(n, false);",
      "      priority_queue<",
      "        std::pair<T, int>,",
      "        std::vector<std::pair<T, int>>,",
      "        greater<std::pair<T, int>>",
      "      > que;",
      "      que.emplace(0, 0);",
      "      while (!que.empty()) {",
      "        T w; int t;",
      "        std::tie(w, t) = que.top(), que.pop();",
      "        if (ckd[t]) continue;",
      "        weight_of_mst += w, ckd[t] = true;",
      "        for (auto p : grh[t]) que.push(p);",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "prim"
  },
  "../include/graph/topological_sort_1.hpp": {
    "body": [
      "class topological_sort {",
      "  const int n;",
      "  const std::vector<std::vector<int>>& grh;",
      "  std::vector<int> srd;",
      "  std::vector<int> ckd;",
      "  bool flg;",
      "",
      "  bool dfs (int crr) {",
      "    if (ckd[crr] == 1) return true;",
      "    if (ckd[crr] == 2) return false;",
      "    bool ret = false;",
      "    ckd[crr] = 1;",
      "    for (int nxt : grh[crr]) {",
      "      ret |= dfs(nxt);",
      "    }",
      "    ckd[crr] = 2;",
      "    srd.insert(srd.begin(), crr);",
      "    return ret;",
      "  }",
      "",
      "  public:",
      "    topological_sort (",
      "        const std::vector<std::vector<int>>& grh",
      "      ) :",
      "      n(grh.size()),",
      "      grh(grh),",
      "      srd(),",
      "      ckd(n, 0),",
      "      flg(",
      "          [&](){",
      "            bool ret = false;",
      "            for (int i = 0; i < n; i++) {",
      "              flg |= (ckd[i] == 0 && dfs(i));",
      "            }",
      "            return ret;",
      "          }()",
      "        )",
      "      {",
      "      }",
      "    bool has_cycle () {return flg;}",
      "    auto sorted() const -> const std::vector<int>& {return srd;}",
      "    auto operator [] (int i) const -> int {return srd[i];}",
      "};"
    ],
    "prefix": "topological_sort_1"
  },
  "../include/graph/topological_sort_2.hpp": {
    "body": [
      "// none (tail)"
    ],
    "prefix": "topological_sort_2"
  },
  "../include/matricis/gauss_jordan_int.hpp": {
    "body": [
      "class gauss_jordan {",
      "  const int h, w;",
      "  int rk;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> p, a;",
      "  void init () {",
      "    for (int j = 0; j < w; j++) {",
      "      for (int pvt = 0; pvt < h; pvt++) {",
      "        if (ckd[pvt]) continue;",
      "        if (a[j] >> pvt & 1) {",
      "          ckd[pvt] = true; rk++;",
      "          int comb = a[j] ^ 1 << pvt;",
      "          for (int i = 0; i < h; i++) if (p[i] >> pvt & 1) p[i] ^= comb;",
      "          for (int k = j; k < w; k++) if (a[k] >> pvt & 1) a[k] ^= comb;",
      "          break;",
      "        }",
      "      }",
      "    }",
      "  }",
      "  int transform (int y) const {",
      "    int z = 0;",
      "    for (int i = 0; i < h; i++) {",
      "      if (y >> i & 1) z |= p[i];",
      "    }",
      "    return z;",
      "  }",
      "  public:",
      "    gauss_jordan (",
      "        std::vector<int> a,",
      "        int h",
      "      ) :",
      "      h(h), w(a.size()), rk(0),",
      "      ckd(h, false),",
      "      p([&]{",
      "        std::vector<int> p(h); ",
      "        for (int i = 0, x = 1; i < h; i++, x *= 2) p[i] = x;",
      "        return p;",
      "      }()),",
      "      a(a)",
      "      {",
      "        init();",
      "      }",
      "    int rank () const {return rk;}",
      "    int kernel () const {return w - rk;}",
      "    int image () const {return h - rk;}",
      "    bool solvable (int y) const {",
      "      assert (!(y >> h));",
      "      int acm = accumulate(a.begin(), a.end(), 0, [](int x, int y){return x | y;});",
      "      int z = transform(y);",
      "      return !(~acm & z);",
      "    }",
      "};"
    ],
    "prefix": "gauss_jordan_int"
  },
  "../include/matricis/square_matrix.hpp": {
    "body": [
      "template <int N, typename Semiring>",
      "class square_matrix",
      "{",
      "  template <int N_, typename Semiring_>",
      "  friend bool operator==(const square_matrix<N_, Semiring_>&, const square_matrix<N_, Semiring_>&);",
      "",
      "  public:",
      "    using this_type   = square_matrix<N, Semiring>;",
      "    using value_type  = typename Semiring::type;",
      "    using matrix_type = std::array<std::array<value_type, N>,  N>;",
      "",
      "  private:",
      "    matrix_type storage;",
      "",
      "  public:",
      "    constexpr square_matrix() = default;",
      "    constexpr square_matrix(const square_matrix&) = default;",
      "    constexpr square_matrix(square_matrix&&) = default;",
      "    square_matrix& operator=(const square_matrix&) = default;",
      "    square_matrix& operator=(square_matrix&&) = default;",
      "",
      "    constexpr square_matrix(const matrix_type& x) : storage(x){}",
      "    constexpr square_matrix",
      "    (",
      "      std::initializer_list<std::initializer_list<value_type>> list",
      "    )",
      "    {",
      "      int i = 0;",
      "      for (auto &row: list)",
      "      {",
      "        int j = 0;",
      "        for (auto val : row)",
      "        {",
      "          storage.at(i).at(j) = val;",
      "          j++;",
      "        }",
      "        i++;",
      "      }",
      "    }",
      "",
      "    // Special Elements.",
      "    static auto zero_matrix()",
      "    {",
      "      auto ret = this_type{};",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          ret.at(i, j) = Semiring::add_id();",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    static auto identity_matrix()",
      "    {",
      "      auto ret = this_type{};",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          ret.at(i, j) = i == j",
      "            ? Semiring::mul_id()",
      "            : Semiring::add_id();",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    // Accessors.",
      "    auto& at(int i, int j)       {return storage.at(i).at(j);}",
      "    auto& at(int i, int j) const {return storage.at(i).at(j);}",
      "",
      "    // Operaters.",
      "    auto& operator+=(const square_matrix& other)",
      "    {",
      "      auto ret = zero_matrix();",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          Semiring::add_eq(at(i,j), other.at(i, j));",
      "        }",
      "      }",
      "      return *this;",
      "    }",
      "",
      "    auto& operator*=(const square_matrix& other)",
      "    {",
      "      auto ret = zero_matrix();",
      "      for (int i = 0; i < N; i++)",
      "      {",
      "        for (int j = 0; j < N; j++)",
      "        {",
      "          for (int k = 0; k < N; k++)",
      "          {",
      "            Semiring::add_eq(ret.at(i, k), Semiring::mul(at(i, j), other.at(j, k)));",
      "          }",
      "        }",
      "      }",
      "      return *this = ret;",
      "    }",
      "};",
      "",
      "template <typename T>",
      "struct is_square_matrix : std::false_type{};",
      "",
      "template <int N, typename Semiring>",
      "struct is_square_matrix<square_matrix<N, Semiring>> : std::true_type{};",
      "",
      "template <typename T>",
      "bool operator==(const T& lhs, const T& rhs) { return lhs.value == rhs.value; }",
      "",
      "template <typename T>",
      "bool operator!=(const T& lhs, const T& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T>",
      "T operator+(T lhs, const T& rhs) { return lhs += rhs; }",
      "",
      "template <typename T>",
      "T operator*(T lhs, const T& rhs) { return lhs *= rhs; }",
      "",
      "",
      "template <int N, typename Semiring>",
      "std::string to_string(const square_matrix<N, Semiring>& a)",
      "{",
      "  using std::literals::string_literals::operator\"\"s;",
      "  auto ret = \"square_matrix{ \"s;",
      "  for (int i = 0; i < N; i++)",
      "  {",
      "    if (i > 0) ret += \", \";",
      "    ret += \"{ \";",
      "    for (int j = 0; j < N; j++)",
      "    {",
      "      if (j > 0) ret += \", \";",
      "      ret += std::to_string(a.at(i, j));",
      "    }",
      "    ret += \" }\";",
      "  }",
      "  ret += \" }\";",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "  using type = T;",
      "  static auto add_id()  {return std::numeric_limits<T>::max();}",
      "  static auto mul_id()  {return 0;}",
      "  static auto add(T x, T y) {return std::min(x, y);}",
      "  static auto mul(T x, T y)",
      "  {",
      "    if (x == add_id() || y == add_id()) return add_id();",
      "    return x + y;",
      "  }",
      "  static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <typename T>",
      "struct min_tolopical",
      "{",
      "  using type = T;",
      "  static auto add_id()  {return std::numeric_limits<T>::min();}",
      "  static auto mul_id()  {return 0;}",
      "  static auto add(T x, T y) {return std::max(x, y);}",
      "  static auto mul(T x, T y)",
      "  {",
      "    if (x == add_id() || y == add_id()) return add_id();",
      "    return x + y;",
      "  }",
      "  static auto add_eq(T& x, T y) {return x = add(x, y);}",
      "};",
      "",
      "template <int N, typename T>",
      "using min_tolopical_matrix = square_matrix<N, min_tolopical<T>>;",
      "",
      "template <int N, typename T>",
      "using max_tolopical_matrix = square_matrix<N, min_tolopical<T>>;"
    ],
    "prefix": "square_matrix"
  },
  "../include/network_flow/bipartite_matching.hpp": {
    "body": [
      "class bipartite_matching {",
      "  int x, y;",
      "  dinic<int> dnc;",
      "  public:",
      "    bipartite_matching(int x, int y) :",
      "      x(x), y(y), dnc([x, y]{",
      "        dinic<int> dnc(1 + x + y + 1, 0, 1 + x + y);",
      "        for (int i = 0; i < x; i++) dnc.insert(0, 1 + i, 1);",
      "        for (int j = 0; j < y; j++) dnc.insert(1 + x + j, 1 + x + y, 1);",
      "        return dnc;",
      "      }())",
      "      {}",
      "    void insert (int i, int j) {",
      "      dnc.insert(1 + i, 1 + x + j, 1);",
      "    }",
      "    int cal () {return dnc.cal();}",
      "};"
    ],
    "prefix": "bipartite_matching"
  },
  "../include/network_flow/dinic.hpp": {
    "body": [
      "template <typename T>",
      "class dinic {",
      "  struct edge {",
      "    int to; T cap;",
      "    weak_ptr<edge> rev;",
      "  };",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<int> dst;",
      "  std::vector<std::vector<shared_ptr<edge>>> grh;",
      "  static constexpr T inf = numeric_limits<T>::max();",
      "  void bfs () {",
      "    queue<int> que;",
      "    que.emplace(source); dst[source] = 0;",
      "    while (!que.empty()) {",
      "      int crr = que.front(); que.pop();",
      "      for (auto const& e : grh[crr]) {",
      "        if (e->cap == 0) continue;",
      "        int nxt = e->to;",
      "        if (dst[nxt] != -1) continue;",
      "        que.push(nxt); dst[nxt] = dst[crr] + 1;",
      "      }",
      "    }",
      "  }",
      "  T dfs () {",
      "    return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "      if (crr == sink) return f;",
      "      ckd[crr] = true;",
      "      for (auto& e : grh[crr]) {",
      "        int nxt = e->to;",
      "        if (ckd[nxt] || e->cap == 0 || dst[crr] >= dst[nxt]) continue;",
      "        T d = dfs(nxt, min(f, e->cap));",
      "        if (d > 0) {",
      "          e->cap -= d;",
      "          e->rev.lock()->cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      dst[crr] = -1;",
      "      return 0;",
      "    })(source);",
      "  }",
      "  public:",
      "    dinic (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T c) {",
      "      auto e = make_shared<edge>(edge{v, c});",
      "      auto r = make_shared<edge>(edge{u, 0});",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal() {",
      "      T ret = 0;",
      "      while (true) {",
      "        dst.assign(n, -1);",
      "        bfs();",
      "        if (dst[sink] == -1) return ret;",
      "        ckd.assign(n, false);",
      "        while (true) {",
      "          T f = dfs();",
      "          if (f == 0) break;",
      "          ret += f;",
      "        }",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "dinic"
  },
  "../include/network_flow/ford_fulkerson.hpp": {
    "body": [
      "template <typename T>",
      "class ford_fulkerson {",
      "  struct edge {",
      "    int to; T cap;",
      "    weak_ptr<edge> rev;",
      "    edge(int to, T cap) : to(to), cap(cap) {}",
      "  };",
      "  const int n, source, sink;",
      "  std::vector<bool> ckd;",
      "  std::vector<std::vector<shared_ptr<edge>>> grh;",
      "  static constexpr T inf = numeric_limits<T>::max();",
      "  T dfs () {",
      "    return fix ([&](auto dfs, int crr, int f = inf) -> T {",
      "      if (crr == sink) return f;",
      "      ckd[crr] = true;",
      "      for (auto& e : grh[crr]) {",
      "        if (ckd[e->to] || !e->cap) continue;",
      "        T d = dfs(e->to, min(f, e->cap));",
      "        if (d) {",
      "          e->cap -= d;",
      "          e->rev.lock()->cap += d;",
      "          return d;",
      "        }",
      "      }",
      "      return 0;",
      "    })(source);",
      "  }",
      "  public:",
      "    ford_fulkerson (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T c) {",
      "      auto e = make_shared<edge>(v, c);",
      "      auto r = make_shared<edge>(u, 0);",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal() {",
      "      T ret = 0;",
      "      while (true) {",
      "        ckd.assign(n, false);",
      "        T f = dfs();",
      "        if (!f) return ret;",
      "        ret += f;",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "ford_fulkerson"
  },
  "../include/network_flow/minimum_cost_flow.hpp": {
    "body": [
      "template <typename T, typename U>",
      "class minimum_cost_flow {",
      "  public:",
      "    const T max_flow = numeric_limits<T>::max();",
      "    const U max_dist  = numeric_limits<U>::max();",
      "  private:",
      "    struct edge {",
      "      int to; T cap; U cost;",
      "      weak_ptr<edge> rev;",
      "    };",
      "    const int n, source, sink;",
      "    std::vector<U> dst;",
      "    std::vector<std::vector<shared_ptr<edge>>> grh;",
      "    void bf () {",
      "      dst.assign(n, max_dist); dst[source] = 0;",
      "      for (int t = 0; t < n; t++) {",
      "        bool flg = false;",
      "        for (int i = 0; i < n; i++) {",
      "          for (auto const& e : grh[i]) {",
      "            if (e->cap == 0) continue;",
      "            int crr = i;     U crd = dst[crr];",
      "            int nxt = e->to; U nxd = crd + e->cost;",
      "            if (crd == max_dist) continue;",
      "            if (cmn(dst[nxt], nxd)) flg = true;",
      "          }",
      "        }",
      "        if (!flg) break;",
      "        if (t == n - 1 && flg) assert(false);",
      "      }",
      "    }",
      "    U flush () {",
      "      std::vector<bool> ckd(n, false);",
      "      return fix([&] (auto dfs, int crr, U f) -> U {",
      "        if (ckd[crr]) return 0;",
      "        ckd[crr] = true;",
      "        if (crr == sink) return f;",
      "        for (auto const& e : grh[crr]) {",
      "        if (e->cap == 0) continue;",
      "          U crd = dst[crr];",
      "          int nxt = e->to; U nxd = dst[nxt];",
      "          if (crd + e->cost != nxd) continue;",
      "          U d = dfs(nxt, min(f, e->cap));",
      "          if (d > 0) {",
      "            e->cap -= d;",
      "            e->rev.lock()->cap += d;",
      "            return d;",
      "          }",
      "        }",
      "        return 0;",
      "      })(source, max_flow);",
      "    }",
      "  public:",
      "    minimum_cost_flow (int n, int source, int sink) :",
      "      n(n), source(source), sink(sink), grh(n)",
      "      {}",
      "    void insert(int u, int v, T cap, U cost) {",
      "      auto e = make_shared<edge>(edge{v, cap, cost});",
      "      auto r = make_shared<edge>(edge{u, 0, -cost});",
      "      e->rev = r;",
      "      r->rev = e;",
      "      grh[u].push_back(e);",
      "      grh[v].push_back(r);",
      "    }",
      "    T cal(U required_flow) {",
      "      T ret = 0;",
      "      while (true) {",
      "        bf();",
      "        if (dst[sink] == max_dist) break;",
      "        T d = dst[sink]; U f = flush();",
      "        if (f >= required_flow) {",
      "          ret += d * required_flow;",
      "          return ret;",
      "        } else {",
      "          ret += d * f;",
      "          required_flow -= f;",
      "        }",
      "      }",
      "      return -1;",
      "    }",
      "};"
    ],
    "prefix": "minimum_cost_flow"
  },
  "../include/number_theory/factorials.hpp": {
    "body": [
      "class factorials {",
      "    std::vector<mint> fact, finv;",
      "  public:",
      "    factorials(int n) : fact(n), finv(n) {",
      "      fact.at(0) = 1;",
      "      for (int i = 1; i < n; i++) fact.at(i) = fact.at(i - 1) * mint(i);",
      "      finv.at(n - 1) = mint(1) / fact.at(n - 1);",
      "      for (int i = n - 2; i >= 0; i--) finv.at(i) = finv.at(i + 1) * mint(i + 1);",
      "    }",
      "    // Returns the factorial.",
      "    template <typename T>",
      "    auto const& operator()(T i) const {return fact.at(i);}",
      "    // Returns the inverse of the factorial.",
      "    template <typename T>",
      "    auto const& inv(T i) const {return finv.at(i);}",
      "    // Returns the binominal coefficient.",
      "    template <typename T>",
      "    auto binom(T i, T j) const {",
      "      assert(0 <= i);",
      "      if (j < 0 ||i < j) return mint(0);",
      "      return fact.at(i) * finv.at(j) * finv.at(i - j);",
      "    }",
      "};"
    ],
    "prefix": "factorials"
  },
  "../include/number_theory/factorize.hpp": {
    "body": [
      "class factorize {",
      "  int x;",
      "  map<int, int> mp;",
      "  std::vector<int> pdv;",
      "  std::vector<int> pdv_m;",
      "",
      "  public:",
      "    factorize(",
      "        const int x",
      "      ) :",
      "      x(x), mp(), pdv()",
      "      {",
      "        for (int p = 2; p * p <= x; p++) {",
      "          while (!(x % p)) {",
      "            mp[p]++;",
      "            pdv.push_back(p);",
      "            x /= p;",
      "          }",
      "        }",
      "        if (x != 1) mp[x] = 1;",
      "        pdv.push_back(x);",
      "        pdv_m = pdv.resize(unique(pdv.begin(), pdv.end()) - pdv.begin());",
      "      }",
      "    ",
      "    const auto& factorize () const {return pdv;}",
      "    const auto& prime_divisors () const {return pdv_m;}",
      "    const auto& multiplicities () const {return mp;}",
      "}"
    ],
    "prefix": "factorize"
  },
  "../include/number_theory/gcd.hpp": {
    "body": [
      "template<typename T>",
      "T gcd (T a, T b) {",
      "  if (a < 0) a = -a;",
      "  if (b < 0) b = -b;",
      "  if (a < b) std::swap(a, b);",
      "  while (b) {",
      "    a %= b;",
      "    std::swap(a, b);",
      "  }",
      "  return a;",
      "}"
    ],
    "prefix": "gcd"
  },
  "../include/number_theory/mint.hpp": {
    "body": [
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a; std::swap(a, m);",
      "    u -= t * v; std::swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "template <typename T>",
      "class modular {",
      "  private:",
      "    int value;",
      "  public:",
      "    constexpr modular() = default;",
      "    constexpr modular(const modular&) = default;",
      "    constexpr modular(modular&&) = default;",
      "    modular& operator=(const modular&) = default;",
      "    modular& operator=(modular&&) = default;",
      "",
      "    template <typename U>",
      "    modular (const U& x) {value = normalize(x);}",
      "",
      "    template <typename U>",
      "    static auto normalize(const U& x) {",
      "      int v = static_cast<int>(-mod() <= x && x < mod() ? x : x % mod());",
      "      if (v < 0) v += mod();",
      "      return v;",
      "    }",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "    constexpr static auto mod() { return T::value; }",
      "",
      "    auto& operator+=(const modular& other) {",
      "      if ((value += other.value) >= mod()) value -= mod();",
      "      return *this;",
      "    }",
      "    auto& operator-=(const modular& other) {",
      "      if ((value -= other.value) < 0) value += mod();",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += modular(other); }",
      "    template <typename U>",
      "    auto& operator-=(const U& other) {return *this -= modular(other); }",
      "    auto operator-() const { return modular(-value); }",
      "    auto& operator++() {return *this += 1;}",
      "    auto& operator--() {return *this -= 1;}",
      "    auto  operator++(int) {modular result(*this); operator++(); return result;}",
      "    auto  operator--(int) {modular result(*this); operator--(); return result;}",
      "  ",
      "    template <typename U = T>",
      "    auto& operator*=(const modular& rhs) {",
      "      value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "      return *this;",
      "    }",
      "    auto& operator/=(const modular& other) {",
      "      return *this *= modular(inverse(other.value, mod()));",
      "    }",
      "};",
      "template <typename T> struct is_modular : std::false_type {};",
      "template <typename T> struct is_modular <modular<T>> : std::true_type{};",
      "template <typename T> constexpr bool is_modular_v = is_modular<T>::value;",
      "",
      "template <typename T> bool operator==(const modular<T>& lhs, const modular<T>& rhs) { return lhs.value == rhs.value; }",
      "template <typename T, typename U> bool operator==(const modular<T>& lhs, U rhs) { return lhs == modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const modular<T>& rhs) { return modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(const modular<T>& lhs, U rhs) { return modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> modular<T> operator+(U lhs, const modular<T>& rhs) { return modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(const modular<T>& lhs, U rhs) { return modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> modular<T> operator-(U lhs, const modular<T>& rhs) { return modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(const modular<T>& lhs, U rhs) { return modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> modular<T> operator*(U lhs, const modular<T>& rhs) { return modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(const modular<T>& lhs, U rhs) { return modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> modular<T> operator/(U lhs, const modular<T>& rhs) { return modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "modular<T> pow (const modular<T>& a, U b) {",
      "  assert(b >= 0);",
      "  modular<T> x = a, ret = 1;",
      "  for (; b > 0; b /= 2) {",
      "    if (b % 2 == 1) ret *= x;",
      "    x *= x;",
      "  }",
      "  return ret;",
      "}",
      "",
      "template <typename T>",
      "std::string to_string(const modular<T>& a) {",
      "  return std::to_string(a());",
      "}",
      "template <typename T>",
      "auto operator<<(std::ostream& os, const T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::ostream&>{",
      "    return os << a();",
      "  }",
      "template <typename T>",
      "auto operator>>(std::istream& is, T& a)",
      "  -> std::enable_if_t<is_modular_v<T>, std::istream&> {",
      "  long long x; is >> x;",
      "  a = T(x);",
      "  return is;",
      "}",
      "",
      "/*",
      "using ModType = int;",
      " ",
      "struct VarMod { static ModType value; };",
      "ModType VarMod::value;",
      "ModType& md = VarMod::value;",
      "using Mint = Modular<VarMod>;",
      "*/",
      "",
      "constexpr int md = 1'000'000'007;",
      "using mint = modular<std::integral_constant<std::decay_t<decltype(md)>, md>>;"
    ],
    "prefix": "mint"
  },
  "../include/number_theory/sieve_of_eratosthenes.hpp": {
    "body": [
      "template <size_t N>",
      "class sieve_of_eratosthenes {",
      "    std::bitset<N> is_prime_;",
      "",
      "  public:",
      "    constexpr sieve_of_eratosthenes(){",
      "      is_prime_ = ~is_prime_;",
      "      is_prime_.reset(0), is_prime_.reset(1);",
      "      for (size_t p = 2; p < N; p++) {",
      "        if (!is_prime_.test(p)) continue;",
      "        for (size_t j = 2; j * p < N; j++) {",
      "          is_prime_.reset(p * j);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Return the bitset testing if a number is prime.",
      "    constexpr const auto& is_prime() const {return is_prime_;}",
      "",
      "    // Returns the vector of prime numbers.",
      "    template <typename T>",
      "    auto primes() const {",
      "      std::vector<T> primes{}; ",
      "      for (size_t i = 0; i < N; i++) {",
      "        if (is_prime_.test(i)) primes.push_back(i);",
      "      }",
      "      return primes;",
      "    }",
      "};"
    ],
    "prefix": "sieve_of_eratosthenes"
  },
  "../include/number_theory/tropical.hpp": {
    "body": [
      "template <typename T, typename F, std::enable_if_t<",
      "    std::is_same<std::result_of_t<F(T, T)>, T>::value,",
      "    std::nullptr_t> = nullptr>",
      "class tropical {",
      "    T value;",
      "  ",
      "  public:",
      "    using value_type = T;",
      "    constexpr tropical()=default;",
      "    constexpr tropical(const tropical&)=default;",
      "    constexpr tropical(tropical&&)=default;",
      "    tropical& operator=(const tropical&)=default;",
      "    tropical& operator=(tropical&&)=default;",
      "",
      "    constexpr tropical(T t) : value(t){}",
      "",
      "    auto const& operator()() const { return value; }",
      "    template <typename U>",
      "    explicit operator U() const { return static_cast<U>(value); }",
      "",
      "    auto& operator+=(const tropical& other) {",
      "      value = F{}(value, other.value);",
      "      return *this;",
      "    }",
      "    template <typename U>",
      "    auto& operator+=(const U& other) {return *this += tropical(other); }",
      "  ",
      "    template <typename U = T>",
      "    auto& operator*=(const tropical& other) {",
      "      value += other.value;",
      "      return *this;",
      "    }",
      "};",
      "template <typename T> struct is_tropical : std::false_type{};",
      "template <typename T, typename F> struct is_tropical <tropical<T, F>> : std::true_type{};",
      "template <typename T> constexpr bool is_tropical_v = is_tropical<T>::value;",
      "",
      "template <typename T, std::enable_if_t<",
      "  is_tropical_v<T>, std::nullptr_t> = nullptr>",
      "bool operator==(const T& lhs, const T& rhs) {return lhs.value == rhs.value;}",
      "",
      "template <typename T>",
      "auto operator+(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) += rhs;}",
      "",
      "template <typename T>",
      "auto operator*(const T& lhs, const T& rhs)",
      "  -> std::enable_if_t<is_tropical_v<T>, T>",
      "  {return T(lhs) *= rhs;}",
      "",
      "template <typename T, typename F>",
      "std::string to_string(const tropical<T, F>& a)",
      "  {return std::to_string(a());}",
      "",
      "template <typename T, typename F>",
      "std::ostream& operator<<(std::ostream& os, const tropical<T, F>& a)",
      "  {return os << a();}",
      "",
      "template <typename T, typename F>",
      "std::istream& operator>>(std::istream& is, tropical<T, F>& a)",
      "  {T x; is >> x; a = tropical<T, F>(x); return is;}",
      "",
      "template <typename T>",
      "struct min_fn_object {",
      "  auto operator()(T a, T b) {return std::min(a, b);}",
      "};",
      "template <typename T>",
      "struct max_fn_object {",
      "  auto operator()(T a, T b) {return std::max(a, b);}",
      "};",
      "using min_tropical = tropical<int, min_fn_object<int>>;",
      "using max_tropical = tropical<int, max_fn_object<int>>;"
    ],
    "prefix": "tropical"
  },
  "../include/polynominals/polynominal.hpp": {
    "body": [
      "template <typename T,",
      "  typename T::value_type zero, // TODO: not value_type, but T",
      "  typename T::value_type one,  // TODO: not value_type, but T",
      "  std::enable_if_t<",
      "    is_tropical_v<T>,",
      "  std::nullptr_t> = nullptr>",
      "class polynominal {",
      "  public:",
      "    using value_type     = T;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    container_type value;",
      "  ",
      "  public:",
      "    constexpr polynominal()=default;",
      "    constexpr polynominal(const polynominal&)=default;",
      "    constexpr polynominal(polynominal&&)=default;",
      "    polynominal& operator=(const polynominal&)=default;",
      "    polynominal& operator=(polynominal&&)=default;",
      "",
      "    template <typename... Args>",
      "    polynominal(Args... args) : value(std::forward<Args>(args)...) {}",
      "",
      "    auto operator()(){return value;}",
      "",
      "",
      "};",
      "",
      "template <typename T> struct is_polynominal : std::false_type{};",
      "template <typename T, T zero, T one> struct is_polynominal <polynominal<T, zero, one>> : std::true_type{};",
      "template <typename T> constexpr bool is_polynominal_v = is_polynominal<T>::value;"
    ],
    "prefix": "polynominal"
  },
  "../include/range_queries/binary_indexed_tree.hpp": {
    "body": [
      "template <typename T, typename Add, typename Sub>",
      "class binary_indexed_tree",
      "{",
      "public:",
      "  using size_type         = int;",
      "  using value_type        = T;",
      "  using add_function_type = Add;",
      "  using sub_function_type = Sub;",
      "  using container_type    = std::vector<T>;",
      "",
      "private:",
      "  size_type         n;",
      "  add_function_type add_function;",
      "  sub_function_type sub_function;",
      "  value_type        id;",
      "  container_type    table;",
      "",
      "public:",
      "  binary_indexed_tree",
      "  (",
      "    size_type         size,",
      "    add_function_type add_function,",
      "    sub_function_type sub_function,",
      "    value_type        id,",
      "    container_type    v",
      "  ) :",
      "  n            (std::pow(2, int(std::log2(size)) + 1)),",
      "  add_function (std::move(add_function)),",
      "  sub_function (std::move(sub_function)),",
      "  id           (id),",
      "  table        (n, id)",
      "  {}",
      "",
      "  binary_indexed_tree(",
      "    size_type         size,",
      "    add_function_type add_function,",
      "    sub_function_type sub_function,",
      "    value_type        id",
      "  ) :",
      "    binary_indexed_tree(",
      "      size,",
      "      std::move(add_function),",
      "      std::move(sub_function),",
      "      id,",
      "      container_type(size, id)",
      "    )",
      "  {}",
      "",
      "  auto operator[] (size_type i) const -> value_type",
      "  {",
      "    assert(0 <= i && i < n);",
      "    return query(i, i + 1);",
      "  }",
      "",
      "  auto at (size_type i) const -> value_type",
      "  {",
      "    return operator[](i);",
      "  }",
      "",
      "  // Returns the sum over [0, k[.",
      "  auto cumulative_sum(size_type k) const -> value_type",
      "  {",
      "    static_assert(std::is_same<size_type, int>::value);",
      "    assert(0 <= k && k <= n);",
      "    value_type ret = id;",
      "    for (k--; k >= 0; k &= k + 1, k--) {",
      "      ret = add_function(ret, table.at(k));",
      "    };",
      "    return ret;",
      "  }",
      "",
      "  // Return the sum over [l, r[.",
      "  auto query (size_type l, size_type r) const -> value_type",
      "  {",
      "    assert(0 <= l && l <= r && r <= n);",
      "    return sub_function(cumulative_sum(r), cumulative_sum(l));",
      "  }",
      "",
      "",
      "  void add (size_type i, value_type x)",
      "  {",
      "    assert(0 <= i && i < n);",
      "    for (; i < n; i |= i + 1) {",
      "      table.at(i) = add_function(table.at(i), x);",
      "    }",
      "  }",
      "",
      "  void update (size_type i, value_type x)",
      "  {",
      "    add(i, sub_function(x, at(i)));",
      "  }",
      "};",
      "",
      "template<typename T, typename Add, typename Sub>",
      "auto make_binary_indexed_tree(",
      "  int size,",
      "  Add add_function,",
      "  Sub sub_function,",
      "  T   id",
      ")",
      "{",
      "  return binary_indexed_tree<T, Add, Sub>",
      "  (",
      "    size,",
      "    std::move(add_function),",
      "    std::move(sub_function),",
      "    id",
      "  );",
      "}",
      "",
      "template<typename T, typename Add, typename Sub>",
      "auto make_binary_indexed_tree",
      "(",
      "  int            size,",
      "  Add            add_function,",
      "  Sub            sub_function,",
      "  T              id,",
      "  std::vector<T> v",
      ")",
      "{",
      "  return binary_indexed_tree<T, Add, Sub>",
      "  (",
      "    size,",
      "    std::move(add_function),",
      "    std::move(sub_function),",
      "    id,",
      "    std::move(v)",
      "  );",
      "}"
    ],
    "prefix": "binary_indexed_tree"
  },
  "../include/range_queries/compressed_segment_tree.hpp": {
    "body": [
      "template<typename T, typename U>",
      "class compressed_segment_tree {",
      "  const std::vector<T> a;",
      "  const size_t sz, Sz;",
      "  std::vector<U> seg;",
      "  const std::function<U(U, U)> o;",
      "  const U id;",
      "  auto find (T k) const {",
      "    auto it = std::lower_bound(a.begin(), a.end(), k);",
      "    assert(it != a.end() && *it == k);",
      "    return it - a.begin() + sz;",
      "  }",
      "  public:",
      "    compressed_segment_tree (",
      "        const std::vector<T> a,",
      "        const std::function<U(U, U)> o,",
      "        const U id",
      "      ) :",
      "      a(a),",
      "      sz([&](){",
      "          size_t ret = 1;",
      "          for (; ret < a.size(); ret <<= 1) {}",
      "          return ret;",
      "        }()),",
      "      Sz(sz << 1),",
      "      seg(Sz, id),",
      "      o(o),",
      "      id(id)",
      "      {",
      "      }",
      "    void update (T x, const U& y) {",
      "      auto k = find(x);",
      "      seg[k] = y;",
      "      while(k >>= 1) {",
      "        seg[k] = o(seg[2 * k], seg[2 * k + 1]);",
      "      }",
      "    }",
      "    void add (T x, const U& y) {",
      "      update(x, at(x) + y);",
      "    }",
      "    U query (T l, T r) {",
      "      l = std::lower_bound(a.begin(), a.end(), l) - a.begin();",
      "      r = std::lower_bound(a.begin(), a.end(), r) - a.begin();",
      "      U L = id, R = id;",
      "      for(l += sz, r += sz; l < r; l >>= 1, r >>= 1) {",
      "        if(l & 1) L = o(L, seg[l++]);",
      "        if(r & 1) R = o(seg[--r], R);",
      "      }",
      "      return o(L, R);",
      "    }",
      "    U at (T x) const {",
      "      return seg[find(x)];",
      "    }",
      "    void print () const {",
      "      int n = a.size();",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"\"; for (auto const& e : a) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"val\"; for (auto const& e : a) std::cout << std::setw(4) << at(e); std::cout << std::endl;",
      "      std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "    }",
      "};"
    ],
    "prefix": "compressed_segment_tree"
  },
  "../include/range_queries/disjoint_sparse_table.hpp": {
    "body": [
      "template <typename T>",
      "class disjoint_sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    disjoint_sparse_table (",
      "        const std::vector<T> a,",
      "        const std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1; i < ht; i++) {",
      "            int p = 1 << i; int P = p << 1;",
      "            for (int s = 0; s < n; s += P) {",
      "              int t = min(s + p, n);",
      "              for (int j = t - 2; j >= s; j--) ret[i][j] = o(a[j], ret[i][j + 1]);",
      "              for (int j = t + 1; j < min(s + P, n); j++) ret[i][j] = o(ret[i][j - 1], a[j]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(l <= --r);",
      "        int m = msb[l ^ r];",
      "        return m == -1 ? tab[0][l] : o(tab[m][l], tab[m][r]);",
      "      }",
      "};"
    ],
    "prefix": "disjoint_sparse_table"
  },
  "../include/range_queries/lazy_segment_tree.hpp": {
    "body": [
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3,",
      "  typename UnaryOp1,  typename UnaryOp2",
      "  >",
      "class lazy_segment_tree",
      "{",
      "  public:",
      "    using size_type = int;",
      "",
      "  private:",
      "    struct node",
      "    {",
      "      size_type id, l, r;",
      "      node (size_type id, size_type l, size_type r):",
      "        id(id), l(l), r(r)",
      "        {};",
      "",
      "      auto size () const {return r - l;}",
      "",
      "      auto left_child  () const",
      "      {",
      "        assert(size() > 1);",
      "        return node(id * 2, l, (l + r) / 2);",
      "      }",
      "",
      "      auto right_child () const",
      "      {",
      "        assert(size() > 1);",
      "        return node(id * 2 + 1, (l + r) / 2, r);",
      "      }",
      "    };",
      "",
      "    size_type           n, N;",
      "    BinaryOp1           op1;",
      "    BinaryOp2           op2;",
      "    BinaryOp3           op3;",
      "    Value1              id1;",
      "    Value2              id2;",
      "    UnaryOp1            expand;",
      "    UnaryOp2            shrink;",
      "    std::vector<Value1> table;",
      "    std::vector<Value2> lazy;",
      "    node                initial_node;",
      "",
      "    auto& op1_eq (Value1& x, Value1 y) {return x = op1(x, y);}",
      "    auto& op2_eq (Value1& x, Value2 y) {return x = op2(x, y);}",
      "    auto& op3_eq (Value2& x, Value2 y) {return x = op3(x, y);}",
      "",
      "    void cal (size_type u)",
      "    {",
      "      table.at(u) = op1(table.at(2 * u), table.at(2 * u + 1));",
      "    }",
      "",
      "    auto prop (size_type u)",
      "    {",
      "      op2_eq(table.at(u), lazy.at(u));",
      "      if (u < n)",
      "      {",
      "        op3_eq(lazy.at(2 * u),     shrink(lazy.at(u)));",
      "        op3_eq(lazy.at(2 * u + 1), shrink(lazy.at(u)));",
      "      }",
      "      lazy.at(u)     = id2;",
      "      return table.at(u);",
      "    }",
      "",
      "    auto query_base (size_type l, size_type r, Value2 val, const node& now)",
      "    {",
      "      prop(now.id);",
      "      if (now.r <= l || r <= now.l) return id1;",
      "      else if (l <= now.l && now.r <= r)",
      "      {",
      "        op3_eq(lazy.at(now.id), val);",
      "        return prop(now.id);",
      "      }",
      "      else",
      "      {",
      "        auto ret =op1(",
      "          query_base(l, r, shrink(val), now.left_child()),",
      "          query_base(l, r, shrink(val), now.right_child())",
      "        );",
      "        cal(now.id);",
      "        return ret;",
      "      }",
      "    }",
      "",
      "  public:",
      "    lazy_segment_tree",
      "    (",
      "      size_type size,",
      "      BinaryOp1  op1,",
      "      BinaryOp2  op2,",
      "      BinaryOp3  op3,",
      "      Value1     id1,",
      "      Value2     id2,",
      "      UnaryOp1   expand,",
      "      UnaryOp2   shrink",
      "    ):",
      "      n (std::pow(2, int(std::log2(size)) + 1)), N(n * 2),",
      "      op1(std::move(op1)), op2(std::move(op2)), op3(std::move(op3)),",
      "      id1(id1), id2(id2),",
      "      expand(std::move(expand)), shrink(std::move(shrink)),",
      "      table(N, id1), lazy(N, id2),",
      "      initial_node(1, 0, n)",
      "      {",
      "        std::mt19937 mt(std::random_device{}());",
      "        std::uniform_int_distribution<int> dist(-1'000'000, 1'000'000);",
      "        for (int i = 0; i < 20; i++) {",
      "          Value1 ex1 = dist(mt), ex1_ = dist(mt);",
      "          Value2 ex2 = dist(mt);",
      "          assert(op1(ex1, id1)       == ex1);",
      "          assert(op2(ex1, id2)       == ex1);",
      "          assert(op3(ex2, id2)       == ex2);",
      "          assert(shrink(expand(ex2)) == ex2);",
      "          assert(op2(op1(ex1, ex1_), expand(ex2)) == op1(op2(ex1, ex2), op2(ex1_, ex2)));",
      "        }",
      "      }",
      "",
      "    void build (const std::vector<Value1>& v)",
      "    {",
      "      assert(int(v.size()) <= n);",
      "      std::move(v.begin(), v.end(), table.begin() + n);",
      "      for (int i = n - 1; i >= 0; i--) cal(i);",
      "    }",
      "",
      "    auto at (size_type i) const -> Value1",
      "    {",
      "      return table.at(n + i);",
      "    }",
      "",
      "    void act (size_type l, size_type r, Value2 val)",
      "    {",
      "      for (int i = 1; i < n; i *= 2) {",
      "        val = expand(val);",
      "      }",
      "      query_base(l, r, val, initial_node);",
      "    }",
      "",
      "    auto query (size_type l, size_type r)",
      "    {",
      "      return query_base(l, r, id2, initial_node);",
      "    }",
      "};",
      "",
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3,",
      "  typename UnaryOp1,  typename UnaryOp2",
      "  >",
      "auto make_lazy_segment_tree",
      "(",
      "  int        size,",
      "  BinaryOp1  op1,",
      "  BinaryOp2  op2,",
      "  BinaryOp3  op3,",
      "  Value1     id1,",
      "  Value2     id2,",
      "  UnaryOp1   expand,",
      "  UnaryOp2   shrink",
      ")",
      "{",
      "  return lazy_segment_tree<",
      "    Value1,    Value2,",
      "    BinaryOp1, BinaryOp2, BinaryOp3,",
      "    UnaryOp1,  UnaryOp2",
      "    >",
      "    (",
      "      size, std::move(op1), std::move(op2), std::move(op3),",
      "      id1, id2, std::move(expand), std::move(shrink)",
      "    );",
      "}",
      "",
      "",
      "template<",
      "  typename Value1,    typename Value2,",
      "  typename BinaryOp1, typename BinaryOp2, typename BinaryOp3",
      "  >",
      "auto make_lazy_segment_tree",
      "(",
      "  int        size,",
      "  BinaryOp1  op1,",
      "  BinaryOp2  op2,",
      "  BinaryOp3  op3,",
      "  Value1     id1,",
      "  Value2     id2",
      ")",
      "{",
      "  auto f = [](auto x){return x;};",
      "  return make_lazy_segment_tree",
      "    (",
      "      size, std::move(op1), std::move(op2), std::move(op3),",
      "      id1, id2, std::move(f), std::move(f)",
      "    );",
      "}"
    ],
    "prefix": "lazy_segment_tree"
  },
  "../include/range_queries/segment_tree.hpp": {
    "body": [
      "template<typename Value, typename BinaryOp>",
      "class segment_tree",
      "{",
      "  public:",
      "    using size_type      = int;",
      "    using value_type     = Value;",
      "    using function_type  = BinaryOp;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    size_type       n, N;",
      "    function_type   op;",
      "    value_type      id;",
      "    container_type  table;",
      "",
      "    void cal (size_type u)",
      "    {",
      "      table.at(u) = op(table.at(2 * u), table.at(2 * u + 1));",
      "    }",
      "",
      "  public:",
      "    segment_tree(int size, BinaryOp op, Value id, const std::vector<Value>& v):",
      "      n     (std::pow(2, int(std::log2(size)) + 1)),",
      "      N     (n * 2),",
      "      op    (op),",
      "      id    (id),",
      "      table (N, id)",
      "    {",
      "      assert(n > 0);",
      "      std::move(v.begin(), v.end(), table.begin() + n);",
      "      for (size_type i = n - 1; i != 0; i--) cal(i);",
      "    }",
      "",
      "    segment_tree(int size, BinaryOp op, Value id):",
      "      segment_tree(size, std::move(op), id, std::vector<Value>(size, id))",
      "      {}",
      "",
      "    auto at (size_type i) const -> value_type",
      "    {",
      "      return table.at(n + i);",
      "    }",
      "",
      "    auto query (size_type l, size_type r) const -> value_type",
      "    {",
      "      struct state {size_type top, left, right;};",
      "",
      "      auto ret = id;",
      "      std::stack<state> stk; stk.push({1, 0, n});",
      "      while (!stk.empty())",
      "      {",
      "        auto now = stk.top(); stk.pop();",
      "        if (l <= now.left && now.right <= r)",
      "        {",
      "          ret = op(ret, table.at(now.top));",
      "          continue;",
      "        }",
      "        size_type mid = (now.left + now.right) / 2;",
      "        if (l < mid) stk.push({2 * now.top,     now.left,  mid});",
      "        if (mid < r) stk.push({2 * now.top + 1, mid, now.right});",
      "      }",
      "      return ret;",
      "    }",
      "",
      "    void update (size_type u, value_type val)",
      "    {",
      "      table.at(u += n) = val;",
      "      for (u /= 2; u != 0; u /= 2) cal(u);",
      "    }",
      "",
      "    void add (size_type u, value_type val)",
      "    {",
      "      update(u, at(u) + val);",
      "    }",
      "};",
      "",
      "template<typename Value, typename BinaryOp>",
      "auto make_segment_tree(int size, BinaryOp op, Value vid)",
      "{",
      "  return segment_tree<Value, BinaryOp>(size, std::move(op), vid);",
      "}",
      "",
      "template<typename Value, typename BinaryOp>",
      "auto make_segment_tree(int size, BinaryOp op, Value vid, std::vector<int> v)",
      "{",
      "  return segment_tree<Value, BinaryOp>(size, std::move(op), vid, std::move(v));",
      "}"
    ],
    "prefix": "segment_tree"
  },
  "../include/range_queries/sliding_minimum.hpp": {
    "body": [
      "template <typename T, typename Compare = std::less<T>>",
      "class sliding_minimum {",
      "public:",
      "  using size_type     = int;",
      "  using position_type = int;",
      "  using value_type    = T;",
      "  using sequence_type = std::vector<T>;",
      "  using deque_type    = std::deque<T>;",
      "  using compare_type  = Compare;",
      "",
      "private:",
      "  deque_type que;",
      "",
      "public:",
      "  size_type     n;",
      "  sequence_type v;",
      "  compare_type  cmp;",
      "  position_type left, right;",
      "",
      "  sliding_minimum",
      "  (",
      "    sequence_type const& v",
      "  ) :",
      "  n    (v.size()),",
      "  v    (v),",
      "  cmp  (Compare()),",
      "  left (0),",
      "  right(0)",
      "  {}",
      "",
      "  auto get_left_index() const -> position_type",
      "  {",
      "    return left;",
      "  }",
      "",
      "  auto get_right_index() const -> position_type",
      "  {",
      "    return right;",
      "  }",
      "",
      "  auto query_index() const -> position_type",
      "  {",
      "    assert(!que.empty());",
      "    return que.front();",
      "  }",
      "",
      "  auto query() const -> value_type",
      "  {",
      "    return v.at(query_index());",
      "  }",
      "",
      "  void pop_left()",
      "  {",
      "    if (que.front() == left++) {",
      "      que.pop_front();",
      "    }",
      "    assert(left <= right);",
      "  }",
      "",
      "  void push_right()",
      "  {",
      "    while (!que.empty() && !cmp(v.at(que.back()), v.at(right))) {",
      "      que.pop_back();",
      "    }",
      "    que.push_back(right++);",
      "    assert(right <= n);",
      "  }",
      "",
      "  void slide()",
      "  {",
      "    pop_left();",
      "    push_right();",
      "  }",
      "",
      "  void pop_left_until(int target)",
      "  {",
      "    assert(target <= right);",
      "    while (left < target) pop_left();",
      "  }",
      "",
      "  void push_right_until(int target)",
      "  {",
      "    assert(target <= n);",
      "    while (right < target) push_right();",
      "  }",
      "",
      "  void advance_until(int l, int r)",
      "  {",
      "    push_right_until(r);",
      "    pop_left_until(l);",
      "  }",
      "};"
    ],
    "prefix": "sliding_minimum"
  },
  "../include/range_queries/sparse_table.hpp": {
    "body": [
      "template <typename T>",
      "class sparse_table {",
      "  const int n, ht;",
      "  const std::vector<int> msb;",
      "  const std::function<T(T, T)> o;",
      "  const std::vector<std::vector<T>> tab;",
      "  public:",
      "    sparse_table (",
      "        std::vector<T> a,",
      "        std::function<T(T, T)> o",
      "      ) :",
      "      n(a.size()),",
      "      ht([&](){",
      "          int ret = 1;",
      "          for (int b = 2; b < n; b <<= 1) ret++;",
      "          return ret;",
      "        }()),",
      "      msb([&](){",
      "          int N = 1 << ht;",
      "          auto ret = std::vector<int>(N, 0); ret[0] = -1;",
      "          for (int i = 2; i < N; i++) ret[i] = ret[i >> 1] + 1;",
      "          return ret;",
      "        }()),",
      "      o(o),",
      "      tab([&](){",
      "          auto ret = std::vector<std::vector<T>>(ht, a);",
      "          for (int i = 1, p = 1; i < ht; i++, p <<= 1) {",
      "            for (int j = 0; j < n; j++) {",
      "              ret[i][j] = o(ret[i - 1][j], ret[i - 1][min(j + p, n - 1)]);",
      "            }",
      "          }",
      "          return ret;",
      "        }())",
      "      {",
      "      }",
      "    auto query (",
      "        int l,",
      "        int r",
      "      ) -> T",
      "      {",
      "        assert(0 <= l && l < r && r <= n);",
      "        int i = msb[r - l];",
      "        return o(tab[i][l], tab[i][r - (1 << i)]);",
      "      }",
      "};"
    ],
    "prefix": "sparse_table"
  },
  "../include/string_algorighms/fully_indexable_dictionary.hpp": {
    "body": [
      "class fully_indexable_dictionary {",
      "    using value_t = uint32_t;",
      "    using count_t = unsigned;",
      "    static constexpr size_t sz = 8 * sizeof(uint32_t);",
      "    bool built;",
      "    size_t full_length, n;",
      "    std::vector<value_t> row_data;",
      "    std::vector<count_t> rank_table;",
      "",
      "  public:",
      "    fully_indexable_dictionary(size_t full_length) :",
      "      built(false),",
      "      full_length(full_length),",
      "      n((full_length + sz - 1) / sz),",
      "      row_data(n), rank_table(n) {",
      "        debug(sz, n);",
      "      }",
      "",
      "    // Set the i-th bit.",
      "    void set(size_t i) {",
      "      assert(!built);",
      "      row_data.at(i / sz) |= (1u << i);",
      "    }",
      "",
      "    // Initialize the rank-table.",
      "    void build() {",
      "      assert(!built);",
      "      rank_table = [&]{",
      "        std::vector<count_t> pop_counts(n), rank_table(n);",
      "        std::transform(row_data.begin(), row_data.end(), pop_counts.begin(),",
      "          [](auto x){return __builtin_popcountl(x);});",
      "        std::partial_sum(pop_counts.begin(), pop_counts.end(), rank_table.begin());",
      "        rank_table.insert(rank_table.begin(), 0u);",
      "        return rank_table; ",
      "      }();",
      "      built = true;",
      "      debug(row_data, rank_table);",
      "    }",
      "",
      "    // Access the i-th bit.",
      "    auto access(size_t i) const -> bool {",
      "      return row_data.at(i / sz) >> (i % sz) & 1u;",
      "    }",
      "    // An alias of access",
      "    auto at(size_t i) const -> bool {return access(i);}",
      "    ",
      "    // Count the 1.",
      "    auto rank(size_t i) const -> count_t {",
      "      return rank_table.at(i / sz)",
      "        + __builtin_popcountl(row_data.at(i / sz) & ((1 << (i % sz)) - 1));",
      "    }",
      "",
      "    // Find the k-th 1. (That is the maximal i such that rank(i) <= k.)",
      "    // When not found, returns the full-size of the sequence.",
      "    auto select(size_t k) const -> size_t {",
      "      size_t left = 0, right = full_length + 1, mid;",
      "      while (right - left > 1) {",
      "        mid = (left + right) / 2;",
      "        (rank(mid) <= k ? left : right) = mid;",
      "      }",
      "      return left;",
      "    }",
      "};"
    ],
    "prefix": "fully_indexable_dictionary"
  },
  "../include/string_algorighms/kmp_algorithm.hpp": {
    "body": [
      "auto make_failure_table (std::string w) -> std::vector<int> {",
      "  int n = w.length();",
      "  std::vector<int> ret(n + 1, -1);",
      "  int len = 0, pos = 1;",
      "  while (pos < n) {",
      "    if (w.at(pos) == w.at(len)) {",
      "      ret.at(pos) = ret.at(len);",
      "    } else {",
      "      ret.at(pos) = len;",
      "      len = ret.at(len);",
      "      while (len >= 0 && w.at(len) != w.at(pos)) len = ret.at(len);",
      "    }",
      "    len++, pos++;",
      "  }",
      "  ret.at(pos) = len;",
      "  return ret;",
      "}",
      "",
      "class kmp_search_engine {",
      "    std::string w;",
      "    std::vector<int> failure_table;",
      "",
      "  public:",
      "    kmp_search_engine()=default;",
      "",
      "    kmp_search_engine(std::string w) :",
      "      w(std::move(w)),",
      "      failure_table(std::move(make_failure_table(this->w)))",
      "      {}",
      "",
      "    // Returns the starting positions of all the matches.",
      "    auto search(std::string s) -> std::vector<int> {",
      "      std::vector<int> ret;",
      "      int pos_w = 0, pos_s = 0;",
      "      while (pos_s < (int)s.length()) {",
      "        if (s.at(pos_s) == w.at(pos_w)) {",
      "          pos_s++, pos_w++;",
      "          if (pos_w == (int)w.length()) {",
      "            ret.push_back(pos_s - pos_w);",
      "            pos_w = failure_table.at(pos_w);",
      "          }",
      "        } else {",
      "          pos_w = failure_table.at(pos_w);",
      "          if (pos_w < 0) {",
      "            pos_s++, pos_w++;",
      "          }",
      "        }",
      "      }",
      "      return ret;",
      "    }",
      "};",
      "",
      "// Returns the beginning positions of all the occurence of w in s.",
      "auto kmp_search(std::string w, std::string s) {",
      "  auto kmp = kmp_search_engine(std::move(w));",
      "  return kmp.search(std::move(s));",
      "}"
    ],
    "prefix": "kmp_algorithm"
  },
  "../include/string_algorighms/rolling_hash.hpp": {
    "body": [
      "class rolling_hash {",
      "  public:",
      "    using value_type     = long long;",
      "    using container_type = std::vector<value_type>;",
      "",
      "  private:",
      "    static constexpr size_t  mod_num = 2;",
      "    static constexpr std::array<value_type, mod_num> mods = {",
      "        1'000'000'007,",
      "        1'000'000'009",
      "      };",
      "    static constexpr value_type base    = 9973;",
      "",
      "    size_t                       n;",
      "    std::vector<container_type>  hash_table;",
      "    std::vector<container_type>  pow_table;",
      "",
      "    auto inverse(value_type a, value_type m) const -> value_type {",
      "      value_type u = 0, v = 1;",
      "      while (a != 0) {",
      "        value_type t = m / a;",
      "        m -= t * a; std::swap(a, m);",
      "        u -= t * v; std::swap(u, v);",
      "      }",
      "      assert(m == 1);",
      "      return u;",
      "    }",
      "",
      "  public:",
      "    // ctor, dtor",
      "    explicit rolling_hash() = default;",
      "    explicit rolling_hash(const rolling_hash&) = default;",
      "    explicit rolling_hash(rolling_hash&&) = default;",
      "    rolling_hash& operator=(const rolling_hash&) = default;",
      "    rolling_hash& operator=(rolling_hash&&) = default;",
      "    ~rolling_hash() = default;",
      "",
      "    rolling_hash(const std::string s) :",
      "      n(s.length()),",
      "      hash_table(mod_num, container_type(n + 1, 0)),",
      "      pow_table (mod_num, container_type(n + 1, 1))",
      "      {",
      "        for (size_t i = 0; i < mod_num; i++) {",
      "          auto  mod = mods.at(i);",
      "          auto& tab = hash_table.at(i);",
      "          auto& pab = pow_table.at(i);",
      "          for (size_t j = 0; j < n; j++) {",
      "            tab.at(j + 1) = (tab.at(j) * base + s.at(j)) % mod;",
      "            pab.at(j + 1) = (pab.at(j) * base) % mod;",
      "          }",
      "        }",
      "      }",
      "",
      "    // observers",
      "    auto hash(size_t l, size_t r) const {",
      "      auto ret = std::vector<value_type>{};",
      "      for (size_t i = 0; i < mod_num; i++) {",
      "        const auto  mod = mods.at(i);",
      "        const auto& tab = hash_table.at(i);",
      "        const auto& pab = pow_table.at(i);",
      "        auto &      buf = ret.at(i);",
      "        buf = (tab.at(r) - tab.at(l)) * inverse(pab.at(l), mod) % mod;",
      "      }",
      "      return ret;",
      "    }",
      "};"
    ],
    "prefix": "rolling_hash"
  },
  "../include/string_algorighms/run_length_encoding.hpp": {
    "body": [
      "template<typename T>",
      "class run_length_encoding {",
      "  std::vector<std::pair<int, T>> rle;",
      "  public:",
      "    run_length_encoding(",
      "        std::vector<T> input",
      "      ) :",
      "      rle(0)",
      "      {",
      "        int cnt = 0;",
      "        for (auto it = input.begin(); it != input.end(); it++) {",
      "          auto jt = next(it); cnt++;",
      "          if (jt == input.end() || *it != *jt) {",
      "            rle.emplace_back(cnt, *it);",
      "            cnt = 0;",
      "          }",
      "        }",
      "      }",
      "    auto const& code () const {return rle;}",
      "};"
    ],
    "prefix": "run_length_encoding"
  },
  "../include/string_algorighms/trie.hpp": {
    "body": [
      "template <int Num, typename ConvertFn>",
      "class trie",
      "{",
      "  struct node",
      "  {",
      "    int                   sz;",
      "    std::vector<int>      ids;",
      "    std::array <int, Num> nxt;",
      "",
      "    node():",
      "      sz  (0),",
      "      ids ()",
      "      {",
      "        std::fill(nxt.begin(), nxt.end(), -1);",
      "      }",
      "",
      "     auto& next(int i) {return nxt.at(i);}",
      "  };",
      "",
      "  std::vector<node> storage;",
      "  ConvertFn         f;",
      "",
      "  void insert_impl(const std::string& s, int id)",
      "  {",
      "    std::vector<int> seq(s.length());",
      "    std::transform(s.begin(), s.end(), seq.begin(), f);",
      "    auto pos = 0;",
      "    for (auto x : seq)",
      "    {",
      "      auto& now      = storage.at(pos);",
      "      auto& next_pos = now.next(x);",
      "      now.sz++;",
      "      if (next_pos == -1)",
      "      {",
      "        next_pos = storage.size();",
      "        storage.emplace_back();",
      "      }",
      "      pos = next_pos;",
      "    }",
      "    auto& now = storage.at(pos);",
      "    now.sz++;",
      "    now.ids.emplace_back(id);",
      "  }",
      "",
      "public:",
      "  trie()=default;",
      "  trie(const trie&)=default;",
      "  trie(trie&&)=default;",
      "  trie& operator=(const trie&)=default;",
      "  trie& operator=(trie&&)=default;",
      "",
      "  trie(const ConvertFn& f):",
      "    storage {node{}},",
      "    f       (f)",
      "    {}",
      "",
      "  // The id is automatically issued.",
      "  void insert(const std::string& s)",
      "  {",
      "    insert_impl(s, storage.front().sz);",
      "  }",
      "",
      "  // Return the ids.",
      "  auto find(const std::string& s) -> std::vector<int>",
      "  {",
      "    std::vector<int> seq(s.length());",
      "    std::transform(s.begin(), s.end(), seq.begin(), f);",
      "    auto vid = 0;",
      "    for (auto x : seq)",
      "    {",
      "      vid = storage.at(vid).next(x);",
      "      if (vid == -1) return{};",
      "    }",
      "    return storage.at(vid).ids;",
      "  }",
      "",
      "  // Return the pairs of length & id",
      "  auto find_prefixes(const std::string& s) -> std::vector<std::pair<int, int>>",
      "  {",
      "    int  n   = s.length();",
      "    auto ret = std::vector<std::pair<int, int>>{};",
      "    auto vid = 0;",
      "    for (int i = 0; i < n; i++)",
      "    {",
      "      vid = storage.at(vid).next(f(s.at(i)));",
      "      if (vid == -1) return ret;",
      "      for (auto id : storage.at(vid).ids)",
      "      {",
      "        ret.emplace_back(i + 1, id);",
      "      }",
      "    }",
      "    return ret;",
      "  }",
      "};",
      "",
      "template <int Num, typename ConvertFn>",
      "auto make_trie(const ConvertFn& f)",
      "{",
      "  return trie<Num, ConvertFn>(std::move(f));",
      "}"
    ],
    "prefix": "trie"
  },
  "../include/string_algorighms/z_algorithm.hpp": {
    "body": [
      "#define LOCAL",
      "using std::to_string;",
      "auto to_string(std::string s) -> std::string {",
      "  return '\"' + s + '\"';",
      "}",
      "auto to_string(char c) -> std::string {",
      "  return \"'\" + std::string{c} + \"'\";",
      "}",
      "auto to_string(const char* s) -> std::string {",
      "  return to_string((std::string) s);",
      "}",
      "auto to_string(bool b) -> std::string {",
      "  return (b ? \"true\" : \"false\");",
      "}",
      "template <typename T, typename U>",
      "auto to_string(std::pair<T, U> p) -> std::string {",
      "  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
      "}",
      "template <size_t N>",
      "auto to_string(std::bitset<N> bs) -> std::string {",
      "  std::string res{};",
      "  for (size_t i = 0; i < N; i++)",
      "    res.insert(res.begin(), bs.test(i) ? '1' : '0');",
      "  return res;",
      "}",
      "template <typename T>",
      "auto to_string(T v) -> std::string {",
      "  bool flg = false;",
      "  std::string res = \"{\";",
      "  for (auto const&x : v) {",
      "    if (flg) res += \", \";",
      "    else flg = true;",
      "    res += to_string(x);",
      "  }",
      "  res += \"}\";",
      "  return res;",
      "}",
      "void debug_out() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_out(Head H, Tail... T) {",
      "  std::cerr << \" \" << to_string(H);",
      "  debug_out(T...);",
      "}",
      "#ifdef LOCAL",
      "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
      "#else",
      "#define debug(...) 42",
      "#endif",
      "",
      "auto make_z_array(std::string s) -> std::vector<int> {",
      "  if (s.empty()) return {};",
      "  int n = s.length();",
      "  std::vector<int> ret(n);",
      "  ret.at(0) = n;",
      "  int i = 1, j = 0;",
      "  while (i < n) {",
      "    while (i + j < n && s.at(j) == s.at(i + j)) {",
      "      j++;",
      "    }",
      "    ret.at(i) = j;",
      "    if (j == 0) {",
      "      i++;",
      "    }",
      "    else {",
      "      int k = 1;",
      "      while (i + k < n && k + ret.at(k) < j) {",
      "        ret.at(i + k) = ret.at(k);",
      "        k++;",
      "      }",
      "      i += k, j -= k;",
      "    }",
      "  }",
      "  return ret;",
      "}",
      "",
      "// Returns turns all the occurence of w in s.",
      "auto z_search(std::string w, std::string s, char dammy = '$') -> std::vector<int> {",
      "  if (s.empty()) return {};",
      "  assert(!w.empty());",
      "  int m = w.length(), n = s.length();",
      "  assert(std::find(w.begin(), w.end(), dammy) == w.end());",
      "  assert(std::find(s.begin(), s.end(), dammy) == s.end());",
      "  auto long_string = w + '$' + s;",
      "  auto z_array = make_z_array(std::move(long_string));",
      "  std::vector<int> ret;",
      "  for (int i = 0; i < n; i++) {",
      "    if (z_array.at(m + 1 + i) == m) {",
      "      ret.push_back(i);",
      "    }",
      "  }",
      "  return ret;",
      "}"
    ],
    "prefix": "z_algorithm"
  },
  "../include/tree/heavy_light_decomposition.hpp": {
    "body": [
      "class heavy_light_decomposition",
      "{",
      "  public:",
      "    using size_type  = int;",
      "    using index_type = int;",
      "    using id_type    = int;",
      "    using graph_type = std::vector<std::vector<index_type>>;",
      "    using tablele_type = std::vector<int>;",
      "",
      "  private:",
      "    size_type  n;",
      "    graph_type graph;",
      "    tablele_type prt, sz, depth, vid, ord, head;",
      "",
      "    // Helper",
      "    void first_dfs(index_type x)",
      "    {",
      "      for (auto& y : graph.at(x))",
      "      {",
      "        if (y == prt.at(x)) continue;",
      "        prt.at(y)   = x;",
      "        depth.at(y) = depth.at(x) + 1;",
      "",
      "        first_dfs(y);",
      "",
      "        sz.at(x) += sz.at(y);",
      "        auto& h = graph.at(x).front();",
      "        if (sz.at(h) < sz.at(y))",
      "        {",
      "          std::swap(h, y);",
      "        }",
      "      }",
      "    }",
      "",
      "    // Helper",
      "    void second_dfs(index_type x, id_type& counter)",
      "    {",
      "      ord.at(vid.at(x) = counter++) = x;",
      "      for (auto y : graph.at(x))",
      "      {",
      "        if (y == prt.at(x)) continue;",
      "        head.at(y) = y == graph.at(x).front()",
      "          ? head.at(x)",
      "          : y;",
      "         second_dfs(y, counter);",
      "      }",
      "    }",
      "",
      "  public:",
      "    heavy_light_decomposition()=default;",
      "    heavy_light_decomposition(const heavy_light_decomposition&)=default;",
      "    heavy_light_decomposition(heavy_light_decomposition&&)=default;",
      "    heavy_light_decomposition& operator=(const heavy_light_decomposition&)=default;",
      "    heavy_light_decomposition& operator=(heavy_light_decomposition&&)=default;",
      "",
      "    heavy_light_decomposition(int n) :",
      "      n     (n),",
      "      graph (n),",
      "      prt   (n),",
      "      sz    (n, 1),",
      "      depth (n, 0),",
      "      vid   (n),",
      "      ord   (n),",
      "      head  (n)",
      "      {}",
      "",
      "    // Accessers.",
      "    auto id(index_type x) const {return vid.at(x);}",
      "",
      "    void build (index_type root = 0)",
      "    {",
      "      id_type counter = 0;",
      "      first_dfs(root);",
      "      second_dfs(root, counter);",
      "    }",
      "",
      "    void insert (index_type x, index_type y)",
      "    {",
      "      graph.at(x).push_back(y);",
      "      graph.at(y).push_back(x);",
      "    }",
      "",
      "    template <typename RangeOp>",
      "    void for_each",
      "    (",
      "      index_type     x,",
      "      index_type     y,",
      "      RangeOp const& op,   // range-operation f([vid(x), vid(y)[)",
      "      bool           skip  // skip the top vertex",
      "    )",
      "    {",
      "      while (true)",
      "      {",
      "        if (id(x) > id(y)) std::swap(x, y);",
      "        if (head.at(x) == head.at(y))",
      "        {",
      "          op(id(x) + skip, id(y) + 1);",
      "          break;",
      "        }",
      "        op(id(head.at(y)), id(y) + 1);",
      "        y = prt.at(head.at(y));",
      "      }",
      "    }",
      "};"
    ],
    "prefix": "heavy_light_decomposition"
  },
  "../include/tree/lowest_common_ancestor.hpp": {
    "body": [
      "// Class for calculating LCA.",
      "// Dependent libraries: Combinator.",
      "template <typename T>",
      "class lowest_common_ancestor {",
      "    struct edge {",
      "        size_t to; T cost;",
      "        edge(size_t to, T cost) : to(to), cost(cost){}",
      "      };",
      "    size_t n, lg;",
      "    std::vector<std::vector<edge>>   graph;",
      "    std::vector<unsigned>            depth;",
      "    std::vector<T>                   weighted_depth;",
      "    std::vector<std::vector<size_t>> prt;",
      "  public:",
      "    using cost_type = T;",
      "    lowest_common_ancestor(size_t n) :",
      "      n(n), lg(std::log2(n)),",
      "      graph(n), depth(n, 0), weighted_depth(n, 0),",
      "      prt(lg + 1, std::vector<size_t>(n)) {}",
      "    // Insert an edge.",
      "    void insert (size_t u, size_t v, T cost = 1) {",
      "        graph.at(u).emplace_back(v, cost);",
      "        graph.at(v).emplace_back(u, cost);",
      "      }",
      "    // Build a doubling table.",
      "    void build (size_t root = 0) {",
      "        fix ([&](auto dfs, size_t crr, size_t p) -> void {",
      "          prt.at(0).at(crr) = p;",
      "          for (auto const& e : graph.at(crr)) {",
      "            if (e.to == p) continue;",
      "            depth.at(e.to) = depth.at(crr) + 1;",
      "            weighted_depth.at(e.to) = weighted_depth.at(crr) + e.cost;",
      "            dfs(e.to, crr);",
      "          }",
      "        })(root, root);",
      "        for (size_t p = 1; p <= lg; p++) {",
      "          for (size_t i = 0; i < n; i++) {",
      "            prt.at(p).at(i) = prt.at(p - 1).at(prt.at(p - 1).at(i));",
      "          }",
      "        }",
      "      }",
      "    // Calculate the lca.",
      "    auto operator()(size_t u, size_t v) const -> size_t {",
      "        if (depth.at(u) < depth.at(v)) std::swap(u, v);",
      "        auto diff = depth.at(u) - depth.at(v);",
      "        if (diff > 0) {",
      "          for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "            if (diff > q) u = prt.at(p).at(u), diff -= q;",
      "          }",
      "          u = prt.at(0).at(u), diff--;",
      "        }",
      "        assert(diff == 0), assert(depth.at(u) == depth.at(v));",
      "        if (u == v) return u;",
      "        for (size_t p = lg, q = std::pow(2, lg); p <= lg; p--, q /= 2) {",
      "          auto next_u = prt.at(p).at(u);",
      "          auto next_v = prt.at(p).at(v);",
      "          if (next_u != next_v) u = next_u, v = next_v;",
      "        }",
      "        assert(u != v);",
      "        u = prt.at(0).at(u), v = prt.at(0).at(v), assert(u == v);",
      "        return u;",
      "      }",
      "    // Calculate the count-based distance.",
      "    auto row_dist (size_t u, size_t v) const -> unsigned {",
      "      return depth.at(u) + depth.at(v) - 2 * depth.at(operator()(u, v));}",
      "    // Calculate the count-based distance.",
      "    auto weighted_dist (size_t u, size_t v) const -> T {",
      "      auto& x = weighted_depth;",
      "      return x.at(u) + x.at(v) - 2 * x.at(operator()(u, v));}",
      "};"
    ],
    "prefix": "lowest_common_ancestor"
  },
  "../snippets/algorithms/binary_serch.hpp": {
    "body": [
      "${1:int} ok = ${2:0}, ng = ${3:inf}, md;",
      "while (abs(ok - ng) > 1) {",
      "  md = (ok + ng) >> 1;",
      "  if (${4:ck(md)}) ok = md;",
      "  else ng = md;",
      "}"
    ],
    "prefix": "binary_serch"
  },
  "../snippets/algorithms/dfs1.hpp": {
    "body": [
      "fix ([&](auto dfs, int crr, int p) -> void {",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (nxt == p) continue;",
      "    dfs(nxt, crr);",
      "  }",
      "})(${1:root}, $1);"
    ],
    "prefix": "dfs1"
  },
  "../snippets/algorithms/dfs2.hpp": {
    "body": [
      "fix ([&](auto dfs, int crr) -> void {",
      "  ckd.at(crr) = true;",
      "  for (auto const& nxt : graph.at(crr)) {",
      "    if (ckd.at(nxt)) continue;",
      "    dfs(nxt);",
      "  }",
      "})(${1:root});"
    ],
    "prefix": "dfs2"
  },
  "../snippets/algorithms/grid_bfs.hpp": {
    "body": [
      "std::vector<std::vector<${1:long long}>> dst(h, std::vector<$1>(w, ${4:-1}));",
      "queue<std::pair<int, int>> que;",
      "dst[${2:si}][${3:sj}] = 0, que.emplace($2, $3);",
      "while (!que.empty()) {",
      "  int cri, crj;",
      "  std::tie(cri, crj) = que.front(), que.pop();",
      "  for (int k = 0; k < 4; k++) {",
      "    int nxi = cri + di[k];",
      "    int nxj = crj + dj[k];",
      "    if (",
      "        0 <= nxi && nxi < h &&",
      "        0 <= nxj && nxj <= w &&",
      "        dst[nxi][nxj] == $4 &&",
      "        !grd[nxi][nxj]",
      "      ) dst[nxi][nxj] = dst[cri][crj] + 1, que.emplace(nxi, nxj);",
      "  }",
      "}"
    ],
    "prefix": "grid_bfs"
  },
  "../snippets/algorithms/inner_dfs1.hpp": {
    "body": [
      "  void dfs (",
      "      int crr = 0,",
      "      int prt = 0",
      "    ) {",
      "      for (int const& nxt : grh[crr]) {",
      "        ${2:T} w; int nxt; std::tie(w, nxt) = e;",
      "        if (nxt == prt) continue;",
      "        dfs(nxt, crr);",
      "        chmax(dp[crr], dp[nxt] + w);",
      "      }",
      "    }"
    ],
    "prefix": "inner_dfs1"
  },
  "../snippets/algorithms/lis.hpp": {
    "body": [
      "std::vector<${1:int}> lis;",
      "for (auto crr : ${2:name}) {",
      "  auto lb = std::lower_bound(lis.begin(), lis.end(), crr);",
      "  if (lb == lis.end()) lis.push_back(crr);",
      "  else *lb = crr;",
      "}"
    ],
    "prefix": "lis"
  },
  "../snippets/algorithms/shakutori.hpp": {
    "body": [
      "/* init crr, ret */",
      "for (int l = 0, r = 0; l < n; l++) {",
      "  if (r <= l) {",
      "    r = l;",
      "    /* re-init crr */;",
      "  }",
      "  for (; r < n; r++) {",
      "    if (/* cannot push r */) break;",
      "    /* push r */;",
      "  }",
      "  ret += r - l;",
      "  /* pop l */",
      "}"
    ],
    "prefix": "shakutori"
  },
  "../snippets/code_fragments/all.hpp": {
    "body": [
      "${1:name}.begin(), $1.end()"
    ],
    "prefix": "all"
  },
  "../snippets/code_fragments/didj.hpp": {
    "body": [
      "int d${1:i}[4] = {-1, +1, 0, 0};",
      "int d${2:j}[4] = {0, 0, -1, +1};"
    ],
    "prefix": "didj"
  },
  "../snippets/code_fragments/for_const.hpp": {
    "body": [
      "for (auto const & ${1:e}: ${2:name}) {",
      "  $0",
      "}"
    ],
    "prefix": "for_const"
  },
  "../snippets/code_fragments/for_iterator.hpp": {
    "body": [
      "for (auto ${1:it} = ${2:name}.begin(); $1 != $2.end(); it++) {",
      "  $0",
      "}"
    ],
    "prefix": "for_iterator"
  },
  "../snippets/code_fragments/for_range.hpp": {
    "body": [
      "for (auto const& ${1:e} : ${2:name}) {",
      "  $0",
      "}"
    ],
    "prefix": "for_range"
  },
  "../snippets/code_fragments/for_reverse.hpp": {
    "body": [
      "for (int ${1:i} = ${2:n - 1}; $1 >= ${3:0}; $1--) {",
      "  $0",
      "}"
    ],
    "prefix": "for_reverse"
  },
  "../snippets/code_fragments/fors.hpp": {
    "body": [
      "for (${1:int} ${2:i} = ${3:0}; $2 < ${4:n}; $2++) {",
      "  $0",
      "}"
    ],
    "prefix": "fors"
  },
  "../snippets/code_fragments/inf.hpp": {
    "body": [
      "constexpr int inf = 1 << 30;"
    ],
    "prefix": "inf"
  },
  "../snippets/code_fragments/interval_dp.hpp": {
    "body": [
      "for (int d = 1; d <= ${1:n}; d++) {",
      "  for (int l = 0, r = d; r <= $1; l++, r++) {",
      "    $0",
      "  }",
      "}"
    ],
    "prefix": "interval_dp"
  },
  "../snippets/code_fragments/lambda.hpp": {
    "body": [
      "auto ${1:name} = [&] ($2) {",
      "  $0",
      "};"
    ],
    "prefix": "lambda"
  },
  "../snippets/code_fragments/long_inf.hpp": {
    "body": [
      "constexpr long long inf = 1LL << 60;"
    ],
    "prefix": "long_inf"
  },
  "../snippets/code_fragments/lower_bound.hpp": {
    "body": [
      "std::lower_bound(${1:name}.begin(), ${1:name}.end(), ${2:});"
    ],
    "prefix": "lower_bound"
  },
  "../snippets/code_fragments/output_stream.hpp": {
    "body": [
      "copy(${1:a}.begin(), $1.end(), ostream_iterator<${2:int}>(std::cout, \" \"));",
      "$0"
    ],
    "prefix": "output_stream"
  },
  "../snippets/code_fragments/pair.hpp": {
    "body": [
      "std::pair<${1:int}, ${2:int}> ${3:name}(${4:0}, ${5:0})$0;"
    ],
    "prefix": "pair"
  },
  "../snippets/code_fragments/reverse.hpp": {
    "body": [
      "reverse(${1:name}.begin(), ${1:name}.end());"
    ],
    "prefix": "reverse"
  },
  "../snippets/code_fragments/reverse_priority_queue.hpp": {
    "body": [
      "priority_queue<",
      "  ${1:std::pair<int, int>},",
      "  std::vector<$1>,",
      "  greater<$1>",
      "> ${2:que};",
      "$2.emplace($0);"
    ],
    "prefix": "reverse_priority_queue"
  },
  "../snippets/code_fragments/sort.hpp": {
    "body": [
      "sort(${1:name}.begin(), ${1:name}.end());"
    ],
    "prefix": "sort"
  },
  "../snippets/code_fragments/sort_reverse.hpp": {
    "body": [
      "sort(${1:name}.begin(), ${1:name}.end(), greater<${2:int}>());"
    ],
    "prefix": "sort_reverse"
  },
  "../snippets/code_fragments/stemp.hpp": {
    "body": [
      "#include <bits/stdc++.h>",
      "#define loop(n) for (int ngtkana_is_geneous = 0; ngtkana_is_geneous < n; ngtkana_is_geneous++)",
      "#define rep(i, begin, end) for(int i = begin; i < end; i++)",
      "",
      "int main()",
      "{",
      "  std::cin.tie(0); std::cin.sync_with_stdio(false);",
      "  $0",
      "  return 0;",
      "}"
    ],
    "prefix": "stemp"
  },
  "../snippets/code_fragments/upper_bound.hpp": {
    "body": [
      "std::upper_bound(${1:name}.begin(), ${1:name.end(), ${2:});"
    ],
    "prefix": "upper_bound"
  },
  "../snippets/code_fragments/vec.hpp": {
    "body": [
      "std::vector<${1:int}> ${2:name}(${3:n});$0"
    ],
    "prefix": "vec"
  },
  "../snippets/code_fragments/vecpair.hpp": {
    "body": [
      "std::vector<std::pair<${1:int}, ${2:int}>> ${3:name}(${4:n}, {${5:0}, ${6:0}})$0;"
    ],
    "prefix": "vecpair"
  },
  "../snippets/code_fragments/vecvec.hpp": {
    "body": [
      "std::vector<std::vector<${1:int}>> ${2:grh}($0);"
    ],
    "prefix": "vecvec"
  },
  "../snippets/code_fragments/vecvecpair.hpp": {
    "body": [
      "std::vector<std::vector<std::pair<${1:int}, ${2:int}>>> ${3:name}(${4:h}, std::vector<std::pair<${1:int}, ${2:int}>>(${5:w}, {${6:0}, ${7:0}}))$0;"
    ],
    "prefix": "vecvecpair"
  },
  "../snippets/debug/-pdbg.hpp": {
    "body": [
      "std::cout << \"(\" << ${1:name}${2:->}first << \", \" << $1$2second << \")\";"
    ],
    "prefix": "-pdbg"
  },
  "../snippets/debug/-ppdbg.hpp": {
    "body": [
      "std::cout << \"(\" << get<0>(${1:*it}) << \", \" << get<1>($1) << \", \" << get<2>($1) << \")\";"
    ],
    "prefix": "-ppdbg"
  },
  "../snippets/debug/-sdbg.hpp": {
    "body": [
      "std::cout << ${1:name};"
    ],
    "prefix": "-sdbg"
  },
  "../snippets/debug/1dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:a} = \" << $1 << std::endl;",
      "} //"
    ],
    "prefix": "1dbg"
  },
  "../snippets/debug/1prompt.hpp": {
    "body": [
      "std::cout << \"${2:a} > \";",
      "${1:int} $2;",
      "std::cin >> $2;"
    ],
    "prefix": "1prompt"
  },
  "../snippets/debug/1vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "1vdebug"
  },
  "../snippets/debug/2dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "2dbg"
  },
  "../snippets/debug/2prpmpt.hpp": {
    "body": [
      "std::cout << \"${2:a}, ${3:b} > \";",
      "${1:int} $2, $3;",
      "std::cin >> $2 >> $3;"
    ],
    "prefix": "2prpmpt"
  },
  "../snippets/debug/2vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "2vdebug"
  },
  "../snippets/debug/3dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2 << \", \"",
      "    << \"${3:c} = \" << $3",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "3dbg"
  },
  "../snippets/debug/3prompt.hpp": {
    "body": [
      "std::cout << \"${2:a}, ${3:b}, ${4:c} > \";",
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3prompt"
  },
  "../snippets/debug/3vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  if (n < (int)${3:name}.size()) n = $3.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "3vdebug"
  },
  "../snippets/debug/4dbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"${1:a} = \" << $1 << \", \"",
      "    << \"${2:b} = \" << $2 << \", \"",
      "    << \"${3:c} = \" << $3 << \", \"",
      "    << \"${4:d} = \" << $4",
      "    << std::endl;",
      "} //"
    ],
    "prefix": "4dbg"
  },
  "../snippets/debug/4vdebug.hpp": {
    "body": [
      "{ // debug",
      "  int n = 0;",
      "  if (n < (int)${1:name}.size()) n = $1.size();",
      "  if (n < (int)${2:name}.size()) n = $2.size();",
      "  if (n < (int)${3:name}.size()) n = $3.size();",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << i; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$1\"; for (auto const& e : $1) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$2\"; for (auto const& e : $2) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$3\"; for (auto const& e : $3) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"$4\"; for (auto const& e : $4) std::cout << std::setw(4) << e; std::cout << std::endl;",
      "  std::cout << std::setw(4) << \"----\"; for (int i = 0; i < n; i++) std::cout << std::setw(4) << \"----\" ; std::cout << std::endl;",
      "} //"
    ],
    "prefix": "4vdebug"
  },
  "../snippets/debug/bug.hpp": {
    "body": [
      "/*    */",
      "$0",
      "/*    */"
    ],
    "prefix": "bug"
  },
  "../snippets/debug/check.hpp": {
    "body": [
      "std::cout << \"/\" << ${1:crr} << std::endl;",
      "std::cout << \"\\\\\\\\\" << ${1:crr} << std::endl;"
    ],
    "prefix": "check"
  },
  "../snippets/debug/interval_debug.hpp": {
    "body": [
      "{ // debug",
      "  std::cout",
      "    << \"[\" << $1 << \", \" << $2 << \")\" << std::endl;",
      "} //"
    ],
    "prefix": "interval_debug"
  },
  "../snippets/debug/map_debug.hpp": {
    "body": [
      "{ // debug",
      "  for (auto ${2:it} = ${1:mp}.begin(); $2 != $1.end(); $2++) {",
      "    std::cout << \"mp[\";",
      "    std::cout << $0$2->first;",
      "    std::cout << \"] = \";",
      "    std::cout << $2->second;",
      "    std::cout << \"\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
      "  }",
      "} //"
    ],
    "prefix": "map_debug"
  },
  "../snippets/debug/ndbg.hpp": {
    "body": [
      "std::cout << \"$0\" << std::endl;"
    ],
    "prefix": "ndbg"
  },
  "../snippets/debug/new_line.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "new_line"
  },
  "../snippets/debug/pdbg.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:name} = (\" << $1${2:.}first << \", \" <<  $1$2second << \")\" << std::endl;",
      "} //"
    ],
    "prefix": "pdbg"
  },
  "../snippets/debug/pretty_debug.hpp": {
    "body": [
      "#define LOCAL",
      "using std::to_string;",
      "auto to_string(std::string s) -> std::string {",
      "  return '\"' + s + '\"';",
      "}",
      "auto to_string(char c) -> std::string {",
      "  return \"'\" + std::string{c} + \"'\";",
      "}",
      "auto to_string(const char* s) -> std::string {",
      "  return to_string((std::string) s);",
      "}",
      "auto to_string(bool b) -> std::string {",
      "  return (b ? \"true\" : \"false\");",
      "}",
      "template <typename T, typename U>",
      "auto to_string(std::pair<T, U> p) -> std::string {",
      "  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
      "}",
      "template <size_t N>",
      "auto to_string(std::bitset<N> bs) -> std::string {",
      "  std::string res{};",
      "  for (size_t i = 0; i < N; i++)",
      "    res.insert(res.begin(), bs.test(i) ? '1' : '0');",
      "  return res;",
      "}",
      "template <typename T>",
      "auto to_string(T v) -> std::string {",
      "  bool flg = false;",
      "  std::string res = \"{\";",
      "  for (auto const&x : v) {",
      "    if (flg) res += \", \";",
      "    else flg = true;",
      "    res += to_string(x);",
      "  }",
      "  res += \"}\";",
      "  return res;",
      "}",
      "void debug_out() { std::cerr << std::endl; }",
      "template <typename Head, typename... Tail>",
      "void debug_out(Head H, Tail... T) {",
      "  std::cerr << \" \" << to_string(H);",
      "  debug_out(T...);",
      "}",
      "#ifdef LOCAL",
      "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
      "#else",
      "#define debug(...) 42",
      "#endif"
    ],
    "prefix": "pretty_debug"
  },
  "../snippets/debug/vpdebug.hpp": {
    "body": [
      "{ // debug",
      "  std::cout << \"${1:name}: \";",
      "  for (auto ${2:it} = $1.begin(); $2 != $1.end(); $2++) {",
      "    std::cout << \"(\";",
      "    std::cout << $2->first;",
      "    std::cout << \", \";",
      "    std::cout << $2->second;",
      "    std::cout << \")\" << (next($2) == $1.end() ? \"\\n\" : \", \");",
      "  }",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "vpdebug"
  },
  "../snippets/debug/vvdbg.hpp": {
    "body": [
      "{ // debug",
      "  int h = ${1:name}.size(); int w = 0;",
      "  int name_length = ${2:3}; int output_length = ${3:4};",
      "  for (int i = 0; i < h; i++) if (w < (int)$1[i].size()) w = $1[i].size();",
      "  std::cout << std::string(name_length, '-') << \"--\";",
      "  for (int j = 0; j < w; j++) std::cout << std::setw(${3:output length}) << \"----\";",
      "  std::cout << std::endl;",
      "  std::cout << std::setw(name_length) << std::right << \"$1\" << \"| \";",
      "  for (int j = 0; j < w; j++) std::cout << std::setw(output_length) << std::right <<  j;",
      "  std::cout << std::endl;",
      "  std::cout << std::string(name_length, '-') << \"+-\";",
      "  for (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
      "  std::cout << std::endl;",
      "  for (int i = 0; i < h; i++) {",
      "    std::cout << std::setw(name_length) << std::right << i << \"| \";",
      "    for (auto const& e : $1[i]) std::cout << std::setw(output_length) << std::right << (e == ${4:0} ? \"0\" : std::to_string(e));",
      "    std::cout << std::endl;",
      "  }",
      "  std::cout << std::string(name_length, '-') << \"--\";",
      "  for (int j = 0; j < w; j++) std::cout << std::string(output_length, '-');",
      "  std::cout << std::endl;",
      "} //"
    ],
    "prefix": "vvdbg"
  },
  "../snippets/io/1sin.hpp": {
    "body": [
      "${1:int} $2; std::cin >> $2;"
    ],
    "prefix": "1sin"
  },
  "../snippets/io/2sin.hpp": {
    "body": [
      "${1:int} $2, $3; std::cin >> $2 >> $3;"
    ],
    "prefix": "2sin"
  },
  "../snippets/io/3sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4;",
      "std::cin >> $2 >> $3 >> $4;"
    ],
    "prefix": "3sin"
  },
  "../snippets/io/4sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5;",
      "std::cin >> $2 >> $3 >> $4 >> $5;"
    ],
    "prefix": "4sin"
  },
  "../snippets/io/5sin.hpp": {
    "body": [
      "${1:int} $2, $3, $4, $5, $6;",
      "std::cin >> $2 >> $3 >> $4 >> $5 >> $6;"
    ],
    "prefix": "5sin"
  },
  "../snippets/io/adjacency_input.hpp": {
    "body": [
      "int ${1:n}, ${2:m};",
      "std::cin >> $1 >> $2;",
      "constexpr ${3:long long} inf = 1LL << 60;",
      "std::vector<std::vector<$3>> adj(n, std::vector<$3>(n, inf));",
      "for (int i = 0; i < $1; i++) adj[i][i] = 0;",
      "for (int i = 0; i < m; i++) {",
      "  $3 d; int s, t;",
      "  std::cin >> s >> t >> d;",
      "  chmin(adj[s][t], d);",
      "}"
    ],
    "prefix": "adjacency_input"
  },
  "../snippets/io/edge_input.hpp": {
    "body": [
      "int ${1:n}, ${2:m};",
      "std::cin >> $1 >> $2;",
      "std::vector<tuple<${3:long long}, int, int>> edg;",
      "for (int i = 0; i < $2; i++) {",
      "  $3 d;",
      "  int s, t;",
      "  std::cin >> s >> t >> d;",
      "  edg.emplace_back(d, ${4:--}s, $4t);",
      "}"
    ],
    "prefix": "edge_input"
  },
  "../snippets/io/err.hpp": {
    "body": [
      "auto err = [&] {",
      "  std::cout << $0 << std::endl;",
      "  exit(0);",
      "};"
    ],
    "prefix": "err"
  },
  "../snippets/io/graph_input.hpp": {
    "body": [
      "std::vector<std::vector<int>> grh(${1:n});",
      "for (int i = 0; i < ${2:n - 1}; i++) {",
      "  int s, t;",
      "  std::cin >> s >> t;",
      "  grh[${3:--}s].push_back($3t);",
      "  grh[t].push_back(s);",
      "}"
    ],
    "prefix": "graph_input"
  },
  "../snippets/io/graph_pair_input.hpp": {
    "body": [
      "std::vector<std::vector<std::pair<${3:long long}, int>>> grh(${1:n});",
      "for (int i = 0; i < ${2:m}; i++) {",
      "  int s, t; $3 d;",
      "  std::cin >> s >> t >> d;",
      "  grh[${4:--}s].emplace_back(d, $4t);",
      "  grh[t].emplace_back(d, s);",
      "}"
    ],
    "prefix": "graph_pair_input"
  },
  "../snippets/io/grid_input.hpp": {
    "body": [
      "int ${1:h}, ${2:w};",
      "std::cin >> $1 >> $2;",
      "std::vector<std::vector<int>> grd($1, std::vector<int>($2));",
      "for (int i = 0; i < $1; i++) {",
      "  for (int j = 0; j < $2; j++) {",
      "    char c;",
      "    std::cin >> c;",
      "    grd[i][j] = c == '#';",
      "  }",
      "}"
    ],
    "prefix": "grid_input"
  },
  "../snippets/io/optional_value.hpp": {
    "body": [
      "(${1:dst[i]} == ${2:inf} ? \"${3:INF}\" : to_string($1))"
    ],
    "prefix": "optional_value"
  },
  "../snippets/io/sout.hpp": {
    "body": [
      "std::cout << $0 << std::endl;"
    ],
    "prefix": "sout"
  },
  "../snippets/io/space_or_newline.hpp": {
    "body": [
      "(${1:i} == ${2:n - 1} ? \" \" : \"\\n\")"
    ],
    "prefix": "space_or_newline"
  },
  "../snippets/io/ternary.hpp": {
    "body": [
      "($1 ? $2 : $3)"
    ],
    "prefix": "ternary"
  },
  "../snippets/io/tin.hpp": {
    "body": [
      "${1:int} ${2:tmp};",
      "std::cin >> $2;",
      "$0;"
    ],
    "prefix": "tin"
  },
  "../snippets/utility/at.hpp": {
    "body": [
      "  // Access the j-th bit.",
      "  auto at = [](unsigned x, size_t j) -> bool {",
      "    return (x >> j) & 1;",
      "  };"
    ],
    "prefix": "at"
  },
  "../snippets/utility/cmn_cmx.hpp": {
    "body": [
      "template<typename T, typename U>",
      "inline auto cmn (T& a, U b) {if (a > b) {a = b; return true;} return false;}",
      "template<typename T, typename U>",
      "inline auto cmx (T& a, U b) {if (a < b) {a = b; return true;} return false;}"
    ],
    "prefix": "cmn_cmx"
  },
  "../snippets/utility/convolution.hpp": {
    "body": [
      "template<typename T>",
      "class convolution {",
      "  const T id;",
      "  const std::function<void(T&, T)> add;",
      "  const std::function<T(T, T)> mul;",
      "  public:",
      "    convolution (",
      "        T id,",
      "        std::function<void(T&, T)> add,",
      "        std::function<T(T, T)> mul",
      "      ) :",
      "      id(id),",
      "      add(add),",
      "      mul(mul)",
      "      {",
      "      }",
      "    auto operator () (",
      "        std::vector<T> a,",
      "        std::vector<T> b",
      "      ) -> std::vector<T>",
      "      {",
      "        int l = a.size();",
      "        int m = b.size();",
      "        int n = l + m - 1;",
      "        assert(l && m);",
      "        std::vector<T> c(n, id);",
      "        for (int i = 0; i < l; i++) {",
      "          for (int j = 0; j < m; j++) {",
      "            add(c[i + j], mul(a[i], b[j]));",
      "          }",
      "        }",
      "        return c;",
      "      }",
      "};",
      "convolution<${1:long long}> cnv(",
      "    ${2:id},",
      "    ${3:add},",
      "    ${4:mul}",
      "  );",
      "  "
    ],
    "prefix": "convolution"
  },
  "../snippets/utility/fix_define.hpp": {
    "body": [
      "auto ${1:cal} = fix ([&](auto $1, $0) -> ${2:int} {",
      "  ",
      "});"
    ],
    "prefix": "fix_define"
  },
  "../snippets/utility/fix_do.hpp": {
    "body": [
      "fix ([&](auto ${1:dfs}, $0) -> ${2:void} {",
      "  ",
      "})();"
    ],
    "prefix": "fix_do"
  },
  "../snippets/utility/free_group.hpp": {
    "body": [
      "class free_group {",
      "  public:",
      "  static inline auto mul(std::string s, std::string t) {",
      "    while (",
      "        !s.empty() && !t.empty() &&",
      "        abs(s.back() - t.front()) == 32",
      "      )",
      "      {",
      "        s.erase(s.end() - 1); t.erase(t.begin());",
      "      }",
      "      return s + t;",
      "  }",
      "  static inline auto inv (std::string s) {",
      "    auto opp = [&] (char& c) {",
      "        if (0 <= c - 'a' && c - 'a' < 26) c -= 32;",
      "        else if (0 <= c - 'A' && c - 'A' < 26) c += 32;",
      "        else assert(false);",
      "      };",
      "    reverse(s.begin(), s.end());",
      "    for_each(s.begin(), s.end(), opp);",
      "    return s;",
      "  }",
      "};"
    ],
    "prefix": "free_group"
  },
  "../snippets/utility/guess.hpp": {
    "body": [
      "struct rational {int n, d;};",
      "auto to_string(rational r) -> std::string {",
      "  return (r.d == 1",
      "    ? std::to_string(r.n)",
      "    : std::to_string(r.n) + \"/\" + std::to_string(r.d));",
      "}",
      "std::ostream& operator << (std::ostream& os, rational r){",
      "  return os << to_string(r);",
      "}",
      "rational guess (mint k) {",
      "  const int dmx = 1000;",
      "  const int nmx = 1000;",
      "  for (int d = 1; d < dmx; d++) {",
      "    int n = int(k * mint(d));",
      "    if (n < nmx) return {n, d};",
      "  }",
      "  return {-1, 0};",
      "}"
    ],
    "prefix": "guess"
  },
  "../snippets/utility/make_higher_vector.hpp": {
    "body": [
      "template <typename T>",
      "auto make_vector(size_t sz, T t) {",
      "  return std::vector<T>(sz, t);",
      "}",
      "template <size_t N, typename T, typename U, std::enable_if_t<",
      "  N == 1, std::nullptr_t> = nullptr>",
      "auto make_higher_vector(size_t sz, U u) {",
      "  return make_vector(sz, T(u));",
      "}",
      "template <size_t N, typename T, std::enable_if_t<",
      "  N == 1, std::nullptr_t> = nullptr>",
      "auto make_higher_vector(size_t sz) {",
      "  return std::vector<T>(sz);",
      "}",
      "template <size_t N, typename T, typename... Args, std::enable_if_t<",
      "  N != 1, std::nullptr_t> = nullptr>",
      "auto make_higher_vector(size_t a, Args... args) {",
      "  return make_vector(a, make_higher_vector<N - 1, T>(args...));",
      "}",
      "template <typename T, typename Size_t>",
      "auto& at(T& t, Size_t i) {",
      "  return t.at(i);",
      "}",
      "template <typename T, typename Size_t, typename... Args>",
      "auto& at(T& t, Size_t i, Args... args) {",
      "  return at(t.at(i), args...);",
      "}"
    ],
    "prefix": "make_higher_vector"
  },
  "../snippets/utility/remove_bit_insert_bit.hpp": {
    "body": [
      "int remove_bit(int x, int j) {",
      "  int low = x & ((1 << j) - 1);",
      "  return ((x >> (j + 1)) << j) + low;",
      "}",
      "int insert_bit(int x, int j, int v) {",
      "  int low = x & ((1 << j) - 1);",
      "  return ((x >> j) << (j + 1)) + (v << j) + low;",
      "}"
    ],
    "prefix": "remove_bit_insert_bit"
  },
  "../snippets/utility/remove_insert_bit.hpp": {
    "body": [
      "  // Remove the j-th bit of x, then shift the upper part to the right.",
      "  auto remove_bit = [](unsigned x, size_t j) -> unsigned {",
      "    return ((x >> (j + 1)) << j) + (x & ((1 << j) - 1));",
      "  };",
      "  // Insert the bit b to x.at(j), shifting the upper part to the left.",
      "  auto insert_bit = [](unsigned x, size_t j, bool b) -> unsigned {",
      "    return ((x >> j) << (j + 1)) + (b << j) + (x & ((1 << j) - 1));",
      "  };"
    ],
    "prefix": "remove_insert_bit"
  }
}